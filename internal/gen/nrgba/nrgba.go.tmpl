// Code generated by go generate; DO NOT EDIT.

// Copyright 2025 Magpie Contributors
// SPDX-License-Identifier: MIT

package nrgba

import (
	"image"

	"github.com/blazeroni/magpie/pkg/core"
    "github.com/blazeroni/magpie/pkg/internal"
)

{{range .}}
// Blend{{.Name}} performs a "{{.Name}}" blend on NRGBA images.
// Logic: {{.KernelDocs}}
func Blend{{.Name}}(pixIter core.PixelIterator, calc core.PixCalculator[*image.NRGBA], compositing internal.BlendCompositing) *image.NRGBA {
    return core.Iterate(pixIter, calc, func(dst, src, out []uint8) {
        for i := 0; i < len(src); i += 4 {
            sA := uint32(src[i+3])
            dA := uint32(dst[i+3])

            if sA == 0 { // Source is transparent
                if compositing&internal.CompositeBlendAndDst != 0 {
                    out[i], out[i+1], out[i+2], out[i+3] = dst[i], dst[i+1], dst[i+2], dst[i+3]
                } else {
                    out[i], out[i+1], out[i+2], out[i+3] = 0, 0, 0, 0
                }
                continue
            }
            if dA == 0 { // Destination is transparent
                if compositing&internal.CompositeBlendAndSrc != 0 {
                    out[i], out[i+1], out[i+2], out[i+3] = src[i], src[i+1], src[i+2], src[i+3]
                } else {
                    out[i], out[i+1], out[i+2], out[i+3] = 0, 0, 0, 0
                }
                continue
            }

            // Both src and dst have some opacity.
            sR, sG, sB := uint32(src[i]), uint32(src[i+1]), uint32(src[i+2])
            dR, dG, dB := uint32(dst[i]), uint32(dst[i+1]), uint32(dst[i+2])
            var oR, oG, oB uint32

            // Calculate the pure blend color
            // region BLEND-SPECIFIC LOGIC
            {{ .KernelR }}
            {{ .KernelG }}
            {{ .KernelB }}
			// endregion BLEND-SPECIFIC LOGIC

            if (sA & dA) == 255 {
                out[i], out[i+1], out[i+2], out[i+3] = uint8(oR), uint8(oG), uint8(oB), 255
                continue
            }

            var compR, compG, compB, compA, outA uint32
            switch compositing {
            case internal.CompositeAll:
                // Case 1: Show both src and dst
                invSA, invDA := 255-sA, 255-dA
                term1, term2, term3 := md255(sA, invDA), md255(dA, invSA), md255(sA, dA)

                compR = md255(term1, sR) + md255(term2, dR) + md255(term3, oR)
                compG = md255(term1, sG) + md255(term2, dG) + md255(term3, oG)
                compB = md255(term1, sB) + md255(term2, dB) + md255(term3, oB)
                compA = sA + term2
                outA = compA
            case internal.CompositeBlendAndSrc:
                // Case 2: Show src only
                invDA := 255 - dA
                term1 := md255(sA, invDA)
                compR = md255(term1, sR) + md255(dA, oR)
                compG = md255(term1, sG) + md255(dA, oG)
                compB = md255(term1, sB) + md255(dA, oB)
                compA = dA + term1
                outA = sA
            case internal.CompositeBlendAndDst:
                // Case 3: Show dst only
                invSA := 255 - sA
                term2 := md255(dA, invSA)
                compR = md255(term2, dR) + md255(sA, oR)
                compG = md255(term2, dG) + md255(sA, oG)
                compB = md255(term2, dB) + md255(sA, oB)
                compA = sA + term2
                outA = dA
            case internal.CompositeBlendOnly:
                // Case 4: Show neither (intersection only)
                oA := md255(sA, dA)
                out[i], out[i+1], out[i+2], out[i+3] = uint8(oR), uint8(oG), uint8(oB), uint8(oA)
                continue
            }

            round := compA / 2
            out[i] = uint8((compR*255 + round) / compA)
            out[i+1] = uint8((compG*255 + round) / compA)
            out[i+2] = uint8((compB*255 + round) / compA)
            out[i+3] = uint8(outA)
        }
    })
}
{{end}}

{{if false}}
// placeholders; available to use in the template
func md255(a, b uint32) uint32 {return 0}
{{end}}