// Code generated by go generate; DO NOT EDIT.

// Copyright 2025 Magpie Contributors
// SPDX-License-Identifier: MIT

package rgba

import (
	"image"

	"github.com/blazeroni/magpie/pkg/core"
    "github.com/blazeroni/magpie/pkg/internal"
)

{{- range . }}

// Blend{{.Name}} performs a '{{.Name}}' blend on RGBA images.
// Logic: {{.KernelDocs}}
func Blend{{.Name}}(pixIter core.PixelIterator, calc core.PixCalculator[*image.RGBA], compositing internal.BlendCompositing) *image.RGBA {
    return core.Iterate(pixIter, calc, func(dst, src, out []uint8) {
		for i := 0; i < len(src); i += 4 {
            sA := uint32(src[i+3])
            dA := uint32(dst[i+3])

            if sA == 0 {
                if compositing&internal.CompositeBlendAndDst != 0 {
                    out[i], out[i+1], out[i+2], out[i+3] = dst[i], dst[i+1], dst[i+2], dst[i+3]
                } else {
                    out[i], out[i+1], out[i+2], out[i+3] = 0, 0, 0, 0
                }
                continue
            }
            if dA == 0 {
                if compositing&internal.CompositeBlendAndSrc != 0 {
                    out[i], out[i+1], out[i+2], out[i+3] = src[i], src[i+1], src[i+2], src[i+3]
                } else {
                    out[i], out[i+1], out[i+2], out[i+3] = 0, 0, 0, 0
                }
                continue
            }

			// pre-multiplied source & destination colors
            sR, sG, sB := uint32(src[i]), uint32(src[i+1]), uint32(src[i+2])
            dR, dG, dB := uint32(dst[i]), uint32(dst[i+1]), uint32(dst[i+2])

            if (sA & dA) == 255 {
                // un-premultiplied kernel color results
                var kR, kG, kB uint32

				// region BLEND-SPECIFIC KERNEL LOGIC
                {{ .KernelR }}
                {{ .KernelG }}
                {{ .KernelB }}
                out[i] = uint8(kR)
                out[i+1] = uint8(kG)
                out[i+2] = uint8(kB)
				// endregion BLEND-SPECIFIC KERNEL LOGIC
                out[i+3] = uint8(255)
                continue
            }

            // final output colors & alpha
            var oRp, oGp, oBp, oA uint32

            {{- if .EquationR }}
			if compositing == internal.CompositeAll {
				// Fast path for Source Over using direct premultiplied equation
				oA = sA + md255(dA, 255-sA)
				// region BLEND-SPECIFIC EQUATION LOGIC
				oRp = {{ .EquationR }}
                oGp = {{ .EquationG }}
				oBp = {{ .EquationB }}
				// endregion BLEND-SPECIFIC EQUATION LOGIC
			} else
			{{- end}}
			{
                // Fallback path for other compositions, or for blend modes without a direct equation.
                // This path is accurate but slower as it must un-premultiply.
                sR = unpremultiply(sR, sA)
                sG = unpremultiply(sG, sA)
                sB = unpremultiply(sB, sA)

                dR = unpremultiply(dR, dA)
                dG = unpremultiply(dG, dA)
                dB = unpremultiply(dB, dA)

                // un-premultiplied kernel color results
                var kR, kG, kB uint32

                // region BLEND-SPECIFIC KERNEL LOGIC
				{{ .KernelR }}
				{{ .KernelG }}
				{{ .KernelB }}
                // endregion BLEND-SPECIFIC KERNEL LOGIC

				// premultiplied compositing color results
				var cRp, cGp, cBp, cA uint32

                // un-premultiplied output colors
                var oRu, oGu, oBu uint32

                switch compositing {
                {{- if not .EquationR }}
                case internal.CompositeAll:
					invSA, invDA := 255-sA, 255-dA
					term1, term2, term3 := md255(sA, invDA), md255(dA, invSA), md255(sA, dA)

					cRp = md255(term1, sR) + md255(term2, dR) + md255(term3, kR)
					cGp = md255(term1, sG) + md255(term2, dG) + md255(term3, kG)
					cBp = md255(term1, sB) + md255(term2, dB) + md255(term3, kB)
					cA = sA + term2

                    oRu = (cRp*255 + cA/2) / cA
                    oGu = (cGp*255 + cA/2) / cA
                    oBu = (cBp*255 + cA/2) / cA
					oA = cA
                {{- end}}
                case internal.CompositeBlendAndSrc:
					cRp = md255(md255(sA, 255-dA), sR) + md255(dA, kR)
					cGp = md255(md255(sA, 255-dA), sG) + md255(dA, kG)
					cBp = md255(md255(sA, 255-dA), sB) + md255(dA, kB)
					cA = dA + md255(sA, 255-dA)

					oRu = (cRp*255 + cA/2) / cA
                    oGu = (cGp*255 + cA/2) / cA
                    oBu = (cBp*255 + cA/2) / cA
					oA = sA
                case internal.CompositeBlendAndDst:
					cRp = md255(md255(dA, 255-sA), dR) + md255(sA, kR)
					cGp = md255(md255(dA, 255-sA), dG) + md255(sA, kG)
					cBp = md255(md255(dA, 255-sA), dB) + md255(sA, kB)
					cA = sA + md255(dA, 255-sA)

					oRu = (cRp*255 + cA/2) / cA
                    oGu = (cGp*255 + cA/2) / cA
                    oBu = (cBp*255 + cA/2) / cA
					oA = dA
                case internal.CompositeBlendOnly:
					oRu, oGu, oBu = kR, kG, kB
					oA = md255(sA, dA)
				}

				oRp = md255(oRu, oA)
				oGp = md255(oGu, oA)
				oBp = md255(oBu, oA)
			}

			out[i]   = uint8(oRp)
			out[i+1] = uint8(oGp)
			out[i+2] = uint8(oBp)
			out[i+3] = uint8(oA)
		}
	})
}
{{- end}}

{{if false}}
// Placeholders; available to use in the template
func md255(a, b uint32) uint32 {return 0}
func unpremultiply(a, b uint32) uint32 {return 0}
{{end}}