// Code generated by go generate; DO NOT EDIT.

// Copyright 2025 Magpie Contributors
// SPDX-License-Identifier: MIT

package nrgba

import (
	"image"

	"github.com/blazeroni/magpie/pkg/core"
	"github.com/blazeroni/magpie/pkg/internal"
)

// BlendColorBurn performs a "ColorBurn" blend on NRGBA images.
// Logic: Cr = 1 - (1 - Cd) / Cs
func BlendColorBurn(pixIter core.PixelIterator, calc core.PixCalculator[*image.NRGBA], compositing internal.BlendCompositing) *image.NRGBA {
	return core.Iterate(pixIter, calc, func(dst, src, out []uint8) {
		for i := 0; i < len(src); i += 4 {
			sA := uint32(src[i+3])
			dA := uint32(dst[i+3])

			if sA == 0 { // Source is transparent
				if compositing&internal.CompositeBlendAndDst != 0 {
					out[i], out[i+1], out[i+2], out[i+3] = dst[i], dst[i+1], dst[i+2], dst[i+3]
				} else {
					out[i], out[i+1], out[i+2], out[i+3] = 0, 0, 0, 0
				}
				continue
			}
			if dA == 0 { // Destination is transparent
				if compositing&internal.CompositeBlendAndSrc != 0 {
					out[i], out[i+1], out[i+2], out[i+3] = src[i], src[i+1], src[i+2], src[i+3]
				} else {
					out[i], out[i+1], out[i+2], out[i+3] = 0, 0, 0, 0
				}
				continue
			}

			// Both src and dst have some opacity.
			sR, sG, sB := uint32(src[i]), uint32(src[i+1]), uint32(src[i+2])
			dR, dG, dB := uint32(dst[i]), uint32(dst[i+1]), uint32(dst[i+2])
			var oR, oG, oB uint32

			// Calculate the pure blend color
			// region BLEND-SPECIFIC LOGIC
			if sR+dR <= 255 {
				oR = 0
			} else {
				oR = 255 - ((255-dR)*255+sR/2)/sR
			}
			if sG+dG <= 255 {
				oG = 0
			} else {
				oG = 255 - ((255-dG)*255+sG/2)/sG
			}
			if sB+dB <= 255 {
				oB = 0
			} else {
				oB = 255 - ((255-dB)*255+sB/2)/sB
			}
			// endregion BLEND-SPECIFIC LOGIC

			if (sA & dA) == 255 {
				out[i], out[i+1], out[i+2], out[i+3] = uint8(oR), uint8(oG), uint8(oB), 255
				continue
			}

			var compR, compG, compB, compA, outA uint32
			switch compositing {
			case internal.CompositeAll:
				// Case 1: Show both src and dst
				invSA, invDA := 255-sA, 255-dA
				term1, term2, term3 := md255(sA, invDA), md255(dA, invSA), md255(sA, dA)

				compR = md255(term1, sR) + md255(term2, dR) + md255(term3, oR)
				compG = md255(term1, sG) + md255(term2, dG) + md255(term3, oG)
				compB = md255(term1, sB) + md255(term2, dB) + md255(term3, oB)
				compA = sA + term2
				outA = compA
			case internal.CompositeBlendAndSrc:
				// Case 2: Show src only
				invDA := 255 - dA
				term1 := md255(sA, invDA)
				compR = md255(term1, sR) + md255(dA, oR)
				compG = md255(term1, sG) + md255(dA, oG)
				compB = md255(term1, sB) + md255(dA, oB)
				compA = dA + term1
				outA = sA
			case internal.CompositeBlendAndDst:
				// Case 3: Show dst only
				invSA := 255 - sA
				term2 := md255(dA, invSA)
				compR = md255(term2, dR) + md255(sA, oR)
				compG = md255(term2, dG) + md255(sA, oG)
				compB = md255(term2, dB) + md255(sA, oB)
				compA = sA + term2
				outA = dA
			case internal.CompositeBlendOnly:
				// Case 4: Show neither (intersection only)
				oA := md255(sA, dA)
				out[i], out[i+1], out[i+2], out[i+3] = uint8(oR), uint8(oG), uint8(oB), uint8(oA)
				continue
			}

			round := compA / 2
			out[i] = uint8((compR*255 + round) / compA)
			out[i+1] = uint8((compG*255 + round) / compA)
			out[i+2] = uint8((compB*255 + round) / compA)
			out[i+3] = uint8(outA)
		}
	})
}

// BlendColorDodge performs a "ColorDodge" blend on NRGBA images.
// Logic: Cr = Cd / (1 - Cs)
func BlendColorDodge(pixIter core.PixelIterator, calc core.PixCalculator[*image.NRGBA], compositing internal.BlendCompositing) *image.NRGBA {
	return core.Iterate(pixIter, calc, func(dst, src, out []uint8) {
		for i := 0; i < len(src); i += 4 {
			sA := uint32(src[i+3])
			dA := uint32(dst[i+3])

			if sA == 0 { // Source is transparent
				if compositing&internal.CompositeBlendAndDst != 0 {
					out[i], out[i+1], out[i+2], out[i+3] = dst[i], dst[i+1], dst[i+2], dst[i+3]
				} else {
					out[i], out[i+1], out[i+2], out[i+3] = 0, 0, 0, 0
				}
				continue
			}
			if dA == 0 { // Destination is transparent
				if compositing&internal.CompositeBlendAndSrc != 0 {
					out[i], out[i+1], out[i+2], out[i+3] = src[i], src[i+1], src[i+2], src[i+3]
				} else {
					out[i], out[i+1], out[i+2], out[i+3] = 0, 0, 0, 0
				}
				continue
			}

			// Both src and dst have some opacity.
			sR, sG, sB := uint32(src[i]), uint32(src[i+1]), uint32(src[i+2])
			dR, dG, dB := uint32(dst[i]), uint32(dst[i+1]), uint32(dst[i+2])
			var oR, oG, oB uint32

			// Calculate the pure blend color
			// region BLEND-SPECIFIC LOGIC
			if sR == 255 {
				oR = 255
			} else {
				oR = min((dR*255)/(255-sR), 255)
			}
			if sG == 255 {
				oG = 255
			} else {
				oG = min((dG*255)/(255-sG), 255)
			}
			if sB == 255 {
				oB = 255
			} else {
				oB = min((dB*255)/(255-sB), 255)
			}
			// endregion BLEND-SPECIFIC LOGIC

			if (sA & dA) == 255 {
				out[i], out[i+1], out[i+2], out[i+3] = uint8(oR), uint8(oG), uint8(oB), 255
				continue
			}

			var compR, compG, compB, compA, outA uint32
			switch compositing {
			case internal.CompositeAll:
				// Case 1: Show both src and dst
				invSA, invDA := 255-sA, 255-dA
				term1, term2, term3 := md255(sA, invDA), md255(dA, invSA), md255(sA, dA)

				compR = md255(term1, sR) + md255(term2, dR) + md255(term3, oR)
				compG = md255(term1, sG) + md255(term2, dG) + md255(term3, oG)
				compB = md255(term1, sB) + md255(term2, dB) + md255(term3, oB)
				compA = sA + term2
				outA = compA
			case internal.CompositeBlendAndSrc:
				// Case 2: Show src only
				invDA := 255 - dA
				term1 := md255(sA, invDA)
				compR = md255(term1, sR) + md255(dA, oR)
				compG = md255(term1, sG) + md255(dA, oG)
				compB = md255(term1, sB) + md255(dA, oB)
				compA = dA + term1
				outA = sA
			case internal.CompositeBlendAndDst:
				// Case 3: Show dst only
				invSA := 255 - sA
				term2 := md255(dA, invSA)
				compR = md255(term2, dR) + md255(sA, oR)
				compG = md255(term2, dG) + md255(sA, oG)
				compB = md255(term2, dB) + md255(sA, oB)
				compA = sA + term2
				outA = dA
			case internal.CompositeBlendOnly:
				// Case 4: Show neither (intersection only)
				oA := md255(sA, dA)
				out[i], out[i+1], out[i+2], out[i+3] = uint8(oR), uint8(oG), uint8(oB), uint8(oA)
				continue
			}

			round := compA / 2
			out[i] = uint8((compR*255 + round) / compA)
			out[i+1] = uint8((compG*255 + round) / compA)
			out[i+2] = uint8((compB*255 + round) / compA)
			out[i+3] = uint8(outA)
		}
	})
}

// BlendDarken performs a "Darken" blend on NRGBA images.
// Logic: Cr = min(Cs, Cd)
func BlendDarken(pixIter core.PixelIterator, calc core.PixCalculator[*image.NRGBA], compositing internal.BlendCompositing) *image.NRGBA {
	return core.Iterate(pixIter, calc, func(dst, src, out []uint8) {
		for i := 0; i < len(src); i += 4 {
			sA := uint32(src[i+3])
			dA := uint32(dst[i+3])

			if sA == 0 { // Source is transparent
				if compositing&internal.CompositeBlendAndDst != 0 {
					out[i], out[i+1], out[i+2], out[i+3] = dst[i], dst[i+1], dst[i+2], dst[i+3]
				} else {
					out[i], out[i+1], out[i+2], out[i+3] = 0, 0, 0, 0
				}
				continue
			}
			if dA == 0 { // Destination is transparent
				if compositing&internal.CompositeBlendAndSrc != 0 {
					out[i], out[i+1], out[i+2], out[i+3] = src[i], src[i+1], src[i+2], src[i+3]
				} else {
					out[i], out[i+1], out[i+2], out[i+3] = 0, 0, 0, 0
				}
				continue
			}

			// Both src and dst have some opacity.
			sR, sG, sB := uint32(src[i]), uint32(src[i+1]), uint32(src[i+2])
			dR, dG, dB := uint32(dst[i]), uint32(dst[i+1]), uint32(dst[i+2])
			var oR, oG, oB uint32

			// Calculate the pure blend color
			// region BLEND-SPECIFIC LOGIC
			oR = min(sR, dR)
			oG = min(sG, dG)
			oB = min(sB, dB)
			// endregion BLEND-SPECIFIC LOGIC

			if (sA & dA) == 255 {
				out[i], out[i+1], out[i+2], out[i+3] = uint8(oR), uint8(oG), uint8(oB), 255
				continue
			}

			var compR, compG, compB, compA, outA uint32
			switch compositing {
			case internal.CompositeAll:
				// Case 1: Show both src and dst
				invSA, invDA := 255-sA, 255-dA
				term1, term2, term3 := md255(sA, invDA), md255(dA, invSA), md255(sA, dA)

				compR = md255(term1, sR) + md255(term2, dR) + md255(term3, oR)
				compG = md255(term1, sG) + md255(term2, dG) + md255(term3, oG)
				compB = md255(term1, sB) + md255(term2, dB) + md255(term3, oB)
				compA = sA + term2
				outA = compA
			case internal.CompositeBlendAndSrc:
				// Case 2: Show src only
				invDA := 255 - dA
				term1 := md255(sA, invDA)
				compR = md255(term1, sR) + md255(dA, oR)
				compG = md255(term1, sG) + md255(dA, oG)
				compB = md255(term1, sB) + md255(dA, oB)
				compA = dA + term1
				outA = sA
			case internal.CompositeBlendAndDst:
				// Case 3: Show dst only
				invSA := 255 - sA
				term2 := md255(dA, invSA)
				compR = md255(term2, dR) + md255(sA, oR)
				compG = md255(term2, dG) + md255(sA, oG)
				compB = md255(term2, dB) + md255(sA, oB)
				compA = sA + term2
				outA = dA
			case internal.CompositeBlendOnly:
				// Case 4: Show neither (intersection only)
				oA := md255(sA, dA)
				out[i], out[i+1], out[i+2], out[i+3] = uint8(oR), uint8(oG), uint8(oB), uint8(oA)
				continue
			}

			round := compA / 2
			out[i] = uint8((compR*255 + round) / compA)
			out[i+1] = uint8((compG*255 + round) / compA)
			out[i+2] = uint8((compB*255 + round) / compA)
			out[i+3] = uint8(outA)
		}
	})
}

// BlendDifference performs a "Difference" blend on NRGBA images.
// Logic: Cr = abs(Cs - Cd)
func BlendDifference(pixIter core.PixelIterator, calc core.PixCalculator[*image.NRGBA], compositing internal.BlendCompositing) *image.NRGBA {
	return core.Iterate(pixIter, calc, func(dst, src, out []uint8) {
		for i := 0; i < len(src); i += 4 {
			sA := uint32(src[i+3])
			dA := uint32(dst[i+3])

			if sA == 0 { // Source is transparent
				if compositing&internal.CompositeBlendAndDst != 0 {
					out[i], out[i+1], out[i+2], out[i+3] = dst[i], dst[i+1], dst[i+2], dst[i+3]
				} else {
					out[i], out[i+1], out[i+2], out[i+3] = 0, 0, 0, 0
				}
				continue
			}
			if dA == 0 { // Destination is transparent
				if compositing&internal.CompositeBlendAndSrc != 0 {
					out[i], out[i+1], out[i+2], out[i+3] = src[i], src[i+1], src[i+2], src[i+3]
				} else {
					out[i], out[i+1], out[i+2], out[i+3] = 0, 0, 0, 0
				}
				continue
			}

			// Both src and dst have some opacity.
			sR, sG, sB := uint32(src[i]), uint32(src[i+1]), uint32(src[i+2])
			dR, dG, dB := uint32(dst[i]), uint32(dst[i+1]), uint32(dst[i+2])
			var oR, oG, oB uint32

			// Calculate the pure blend color
			// region BLEND-SPECIFIC LOGIC
			oR = min(sR-dR, dR-sR)
			oG = min(sG-dG, dG-sG)
			oB = min(sB-dB, dB-sB)
			// endregion BLEND-SPECIFIC LOGIC

			if (sA & dA) == 255 {
				out[i], out[i+1], out[i+2], out[i+3] = uint8(oR), uint8(oG), uint8(oB), 255
				continue
			}

			var compR, compG, compB, compA, outA uint32
			switch compositing {
			case internal.CompositeAll:
				// Case 1: Show both src and dst
				invSA, invDA := 255-sA, 255-dA
				term1, term2, term3 := md255(sA, invDA), md255(dA, invSA), md255(sA, dA)

				compR = md255(term1, sR) + md255(term2, dR) + md255(term3, oR)
				compG = md255(term1, sG) + md255(term2, dG) + md255(term3, oG)
				compB = md255(term1, sB) + md255(term2, dB) + md255(term3, oB)
				compA = sA + term2
				outA = compA
			case internal.CompositeBlendAndSrc:
				// Case 2: Show src only
				invDA := 255 - dA
				term1 := md255(sA, invDA)
				compR = md255(term1, sR) + md255(dA, oR)
				compG = md255(term1, sG) + md255(dA, oG)
				compB = md255(term1, sB) + md255(dA, oB)
				compA = dA + term1
				outA = sA
			case internal.CompositeBlendAndDst:
				// Case 3: Show dst only
				invSA := 255 - sA
				term2 := md255(dA, invSA)
				compR = md255(term2, dR) + md255(sA, oR)
				compG = md255(term2, dG) + md255(sA, oG)
				compB = md255(term2, dB) + md255(sA, oB)
				compA = sA + term2
				outA = dA
			case internal.CompositeBlendOnly:
				// Case 4: Show neither (intersection only)
				oA := md255(sA, dA)
				out[i], out[i+1], out[i+2], out[i+3] = uint8(oR), uint8(oG), uint8(oB), uint8(oA)
				continue
			}

			round := compA / 2
			out[i] = uint8((compR*255 + round) / compA)
			out[i+1] = uint8((compG*255 + round) / compA)
			out[i+2] = uint8((compB*255 + round) / compA)
			out[i+3] = uint8(outA)
		}
	})
}

// BlendDivide performs a "Divide" blend on NRGBA images.
// Logic: Cr = Cd / Cs
func BlendDivide(pixIter core.PixelIterator, calc core.PixCalculator[*image.NRGBA], compositing internal.BlendCompositing) *image.NRGBA {
	return core.Iterate(pixIter, calc, func(dst, src, out []uint8) {
		for i := 0; i < len(src); i += 4 {
			sA := uint32(src[i+3])
			dA := uint32(dst[i+3])

			if sA == 0 { // Source is transparent
				if compositing&internal.CompositeBlendAndDst != 0 {
					out[i], out[i+1], out[i+2], out[i+3] = dst[i], dst[i+1], dst[i+2], dst[i+3]
				} else {
					out[i], out[i+1], out[i+2], out[i+3] = 0, 0, 0, 0
				}
				continue
			}
			if dA == 0 { // Destination is transparent
				if compositing&internal.CompositeBlendAndSrc != 0 {
					out[i], out[i+1], out[i+2], out[i+3] = src[i], src[i+1], src[i+2], src[i+3]
				} else {
					out[i], out[i+1], out[i+2], out[i+3] = 0, 0, 0, 0
				}
				continue
			}

			// Both src and dst have some opacity.
			sR, sG, sB := uint32(src[i]), uint32(src[i+1]), uint32(src[i+2])
			dR, dG, dB := uint32(dst[i]), uint32(dst[i+1]), uint32(dst[i+2])
			var oR, oG, oB uint32

			// Calculate the pure blend color
			// region BLEND-SPECIFIC LOGIC
			if sR == 0 {
				oR = 255
			} else {
				oR = min((dR*255+sR/2)/sR, 255)
			}
			if sG == 0 {
				oG = 255
			} else {
				oG = min((dG*255+sG/2)/sG, 255)
			}
			if sB == 0 {
				oB = 255
			} else {
				oB = min((dB*255+sB/2)/sB, 255)
			}
			// endregion BLEND-SPECIFIC LOGIC

			if (sA & dA) == 255 {
				out[i], out[i+1], out[i+2], out[i+3] = uint8(oR), uint8(oG), uint8(oB), 255
				continue
			}

			var compR, compG, compB, compA, outA uint32
			switch compositing {
			case internal.CompositeAll:
				// Case 1: Show both src and dst
				invSA, invDA := 255-sA, 255-dA
				term1, term2, term3 := md255(sA, invDA), md255(dA, invSA), md255(sA, dA)

				compR = md255(term1, sR) + md255(term2, dR) + md255(term3, oR)
				compG = md255(term1, sG) + md255(term2, dG) + md255(term3, oG)
				compB = md255(term1, sB) + md255(term2, dB) + md255(term3, oB)
				compA = sA + term2
				outA = compA
			case internal.CompositeBlendAndSrc:
				// Case 2: Show src only
				invDA := 255 - dA
				term1 := md255(sA, invDA)
				compR = md255(term1, sR) + md255(dA, oR)
				compG = md255(term1, sG) + md255(dA, oG)
				compB = md255(term1, sB) + md255(dA, oB)
				compA = dA + term1
				outA = sA
			case internal.CompositeBlendAndDst:
				// Case 3: Show dst only
				invSA := 255 - sA
				term2 := md255(dA, invSA)
				compR = md255(term2, dR) + md255(sA, oR)
				compG = md255(term2, dG) + md255(sA, oG)
				compB = md255(term2, dB) + md255(sA, oB)
				compA = sA + term2
				outA = dA
			case internal.CompositeBlendOnly:
				// Case 4: Show neither (intersection only)
				oA := md255(sA, dA)
				out[i], out[i+1], out[i+2], out[i+3] = uint8(oR), uint8(oG), uint8(oB), uint8(oA)
				continue
			}

			round := compA / 2
			out[i] = uint8((compR*255 + round) / compA)
			out[i+1] = uint8((compG*255 + round) / compA)
			out[i+2] = uint8((compB*255 + round) / compA)
			out[i+3] = uint8(outA)
		}
	})
}

// BlendExclusion performs a "Exclusion" blend on NRGBA images.
// Logic: Cr = Cs + Cd - 2 * Cs * Cd
func BlendExclusion(pixIter core.PixelIterator, calc core.PixCalculator[*image.NRGBA], compositing internal.BlendCompositing) *image.NRGBA {
	return core.Iterate(pixIter, calc, func(dst, src, out []uint8) {
		for i := 0; i < len(src); i += 4 {
			sA := uint32(src[i+3])
			dA := uint32(dst[i+3])

			if sA == 0 { // Source is transparent
				if compositing&internal.CompositeBlendAndDst != 0 {
					out[i], out[i+1], out[i+2], out[i+3] = dst[i], dst[i+1], dst[i+2], dst[i+3]
				} else {
					out[i], out[i+1], out[i+2], out[i+3] = 0, 0, 0, 0
				}
				continue
			}
			if dA == 0 { // Destination is transparent
				if compositing&internal.CompositeBlendAndSrc != 0 {
					out[i], out[i+1], out[i+2], out[i+3] = src[i], src[i+1], src[i+2], src[i+3]
				} else {
					out[i], out[i+1], out[i+2], out[i+3] = 0, 0, 0, 0
				}
				continue
			}

			// Both src and dst have some opacity.
			sR, sG, sB := uint32(src[i]), uint32(src[i+1]), uint32(src[i+2])
			dR, dG, dB := uint32(dst[i]), uint32(dst[i+1]), uint32(dst[i+2])
			var oR, oG, oB uint32

			// Calculate the pure blend color
			// region BLEND-SPECIFIC LOGIC
			oR = sR + dR - 2*md255(sR, dR)
			oG = sG + dG - 2*md255(sG, dG)
			oB = sB + dB - 2*md255(sB, dB)
			// endregion BLEND-SPECIFIC LOGIC

			if (sA & dA) == 255 {
				out[i], out[i+1], out[i+2], out[i+3] = uint8(oR), uint8(oG), uint8(oB), 255
				continue
			}

			var compR, compG, compB, compA, outA uint32
			switch compositing {
			case internal.CompositeAll:
				// Case 1: Show both src and dst
				invSA, invDA := 255-sA, 255-dA
				term1, term2, term3 := md255(sA, invDA), md255(dA, invSA), md255(sA, dA)

				compR = md255(term1, sR) + md255(term2, dR) + md255(term3, oR)
				compG = md255(term1, sG) + md255(term2, dG) + md255(term3, oG)
				compB = md255(term1, sB) + md255(term2, dB) + md255(term3, oB)
				compA = sA + term2
				outA = compA
			case internal.CompositeBlendAndSrc:
				// Case 2: Show src only
				invDA := 255 - dA
				term1 := md255(sA, invDA)
				compR = md255(term1, sR) + md255(dA, oR)
				compG = md255(term1, sG) + md255(dA, oG)
				compB = md255(term1, sB) + md255(dA, oB)
				compA = dA + term1
				outA = sA
			case internal.CompositeBlendAndDst:
				// Case 3: Show dst only
				invSA := 255 - sA
				term2 := md255(dA, invSA)
				compR = md255(term2, dR) + md255(sA, oR)
				compG = md255(term2, dG) + md255(sA, oG)
				compB = md255(term2, dB) + md255(sA, oB)
				compA = sA + term2
				outA = dA
			case internal.CompositeBlendOnly:
				// Case 4: Show neither (intersection only)
				oA := md255(sA, dA)
				out[i], out[i+1], out[i+2], out[i+3] = uint8(oR), uint8(oG), uint8(oB), uint8(oA)
				continue
			}

			round := compA / 2
			out[i] = uint8((compR*255 + round) / compA)
			out[i+1] = uint8((compG*255 + round) / compA)
			out[i+2] = uint8((compB*255 + round) / compA)
			out[i+3] = uint8(outA)
		}
	})
}

// BlendHardLight performs a "HardLight" blend on NRGBA images.
// Logic: if Cs < 0.5 { Cr = 2 * Cs * Cd } else { Cr = 1 - 2 * (1 - Cs) * (1 - Cd) }
func BlendHardLight(pixIter core.PixelIterator, calc core.PixCalculator[*image.NRGBA], compositing internal.BlendCompositing) *image.NRGBA {
	return core.Iterate(pixIter, calc, func(dst, src, out []uint8) {
		for i := 0; i < len(src); i += 4 {
			sA := uint32(src[i+3])
			dA := uint32(dst[i+3])

			if sA == 0 { // Source is transparent
				if compositing&internal.CompositeBlendAndDst != 0 {
					out[i], out[i+1], out[i+2], out[i+3] = dst[i], dst[i+1], dst[i+2], dst[i+3]
				} else {
					out[i], out[i+1], out[i+2], out[i+3] = 0, 0, 0, 0
				}
				continue
			}
			if dA == 0 { // Destination is transparent
				if compositing&internal.CompositeBlendAndSrc != 0 {
					out[i], out[i+1], out[i+2], out[i+3] = src[i], src[i+1], src[i+2], src[i+3]
				} else {
					out[i], out[i+1], out[i+2], out[i+3] = 0, 0, 0, 0
				}
				continue
			}

			// Both src and dst have some opacity.
			sR, sG, sB := uint32(src[i]), uint32(src[i+1]), uint32(src[i+2])
			dR, dG, dB := uint32(dst[i]), uint32(dst[i+1]), uint32(dst[i+2])
			var oR, oG, oB uint32

			// Calculate the pure blend color
			// region BLEND-SPECIFIC LOGIC
			if sR < 128 {
				oR = 2 * md255(sR, dR)
			} else {
				oR = 255 - 2*md255(255-sR, 255-dR)
			}
			if sG < 128 {
				oG = 2 * md255(sG, dG)
			} else {
				oG = 255 - 2*md255(255-sG, 255-dG)
			}
			if sB < 128 {
				oB = 2 * md255(sB, dB)
			} else {
				oB = 255 - 2*md255(255-sB, 255-dB)
			}
			// endregion BLEND-SPECIFIC LOGIC

			if (sA & dA) == 255 {
				out[i], out[i+1], out[i+2], out[i+3] = uint8(oR), uint8(oG), uint8(oB), 255
				continue
			}

			var compR, compG, compB, compA, outA uint32
			switch compositing {
			case internal.CompositeAll:
				// Case 1: Show both src and dst
				invSA, invDA := 255-sA, 255-dA
				term1, term2, term3 := md255(sA, invDA), md255(dA, invSA), md255(sA, dA)

				compR = md255(term1, sR) + md255(term2, dR) + md255(term3, oR)
				compG = md255(term1, sG) + md255(term2, dG) + md255(term3, oG)
				compB = md255(term1, sB) + md255(term2, dB) + md255(term3, oB)
				compA = sA + term2
				outA = compA
			case internal.CompositeBlendAndSrc:
				// Case 2: Show src only
				invDA := 255 - dA
				term1 := md255(sA, invDA)
				compR = md255(term1, sR) + md255(dA, oR)
				compG = md255(term1, sG) + md255(dA, oG)
				compB = md255(term1, sB) + md255(dA, oB)
				compA = dA + term1
				outA = sA
			case internal.CompositeBlendAndDst:
				// Case 3: Show dst only
				invSA := 255 - sA
				term2 := md255(dA, invSA)
				compR = md255(term2, dR) + md255(sA, oR)
				compG = md255(term2, dG) + md255(sA, oG)
				compB = md255(term2, dB) + md255(sA, oB)
				compA = sA + term2
				outA = dA
			case internal.CompositeBlendOnly:
				// Case 4: Show neither (intersection only)
				oA := md255(sA, dA)
				out[i], out[i+1], out[i+2], out[i+3] = uint8(oR), uint8(oG), uint8(oB), uint8(oA)
				continue
			}

			round := compA / 2
			out[i] = uint8((compR*255 + round) / compA)
			out[i+1] = uint8((compG*255 + round) / compA)
			out[i+2] = uint8((compB*255 + round) / compA)
			out[i+3] = uint8(outA)
		}
	})
}

// BlendHardMix performs a "HardMix" blend on NRGBA images.
// Logic: if Cs + Cd < 1 { Cr = 0 } else { Cr = 1 }
func BlendHardMix(pixIter core.PixelIterator, calc core.PixCalculator[*image.NRGBA], compositing internal.BlendCompositing) *image.NRGBA {
	return core.Iterate(pixIter, calc, func(dst, src, out []uint8) {
		for i := 0; i < len(src); i += 4 {
			sA := uint32(src[i+3])
			dA := uint32(dst[i+3])

			if sA == 0 { // Source is transparent
				if compositing&internal.CompositeBlendAndDst != 0 {
					out[i], out[i+1], out[i+2], out[i+3] = dst[i], dst[i+1], dst[i+2], dst[i+3]
				} else {
					out[i], out[i+1], out[i+2], out[i+3] = 0, 0, 0, 0
				}
				continue
			}
			if dA == 0 { // Destination is transparent
				if compositing&internal.CompositeBlendAndSrc != 0 {
					out[i], out[i+1], out[i+2], out[i+3] = src[i], src[i+1], src[i+2], src[i+3]
				} else {
					out[i], out[i+1], out[i+2], out[i+3] = 0, 0, 0, 0
				}
				continue
			}

			// Both src and dst have some opacity.
			sR, sG, sB := uint32(src[i]), uint32(src[i+1]), uint32(src[i+2])
			dR, dG, dB := uint32(dst[i]), uint32(dst[i+1]), uint32(dst[i+2])
			var oR, oG, oB uint32

			// Calculate the pure blend color
			// region BLEND-SPECIFIC LOGIC
			if sR+dR < 255 {
				oR = 0
			} else {
				oR = 255
			}
			if sG+dG < 255 {
				oG = 0
			} else {
				oG = 255
			}
			if sB+dB < 255 {
				oB = 0
			} else {
				oB = 255
			}
			// endregion BLEND-SPECIFIC LOGIC

			if (sA & dA) == 255 {
				out[i], out[i+1], out[i+2], out[i+3] = uint8(oR), uint8(oG), uint8(oB), 255
				continue
			}

			var compR, compG, compB, compA, outA uint32
			switch compositing {
			case internal.CompositeAll:
				// Case 1: Show both src and dst
				invSA, invDA := 255-sA, 255-dA
				term1, term2, term3 := md255(sA, invDA), md255(dA, invSA), md255(sA, dA)

				compR = md255(term1, sR) + md255(term2, dR) + md255(term3, oR)
				compG = md255(term1, sG) + md255(term2, dG) + md255(term3, oG)
				compB = md255(term1, sB) + md255(term2, dB) + md255(term3, oB)
				compA = sA + term2
				outA = compA
			case internal.CompositeBlendAndSrc:
				// Case 2: Show src only
				invDA := 255 - dA
				term1 := md255(sA, invDA)
				compR = md255(term1, sR) + md255(dA, oR)
				compG = md255(term1, sG) + md255(dA, oG)
				compB = md255(term1, sB) + md255(dA, oB)
				compA = dA + term1
				outA = sA
			case internal.CompositeBlendAndDst:
				// Case 3: Show dst only
				invSA := 255 - sA
				term2 := md255(dA, invSA)
				compR = md255(term2, dR) + md255(sA, oR)
				compG = md255(term2, dG) + md255(sA, oG)
				compB = md255(term2, dB) + md255(sA, oB)
				compA = sA + term2
				outA = dA
			case internal.CompositeBlendOnly:
				// Case 4: Show neither (intersection only)
				oA := md255(sA, dA)
				out[i], out[i+1], out[i+2], out[i+3] = uint8(oR), uint8(oG), uint8(oB), uint8(oA)
				continue
			}

			round := compA / 2
			out[i] = uint8((compR*255 + round) / compA)
			out[i+1] = uint8((compG*255 + round) / compA)
			out[i+2] = uint8((compB*255 + round) / compA)
			out[i+3] = uint8(outA)
		}
	})
}

// BlendLighten performs a "Lighten" blend on NRGBA images.
// Logic: Cr = max(Cs, Cd)
func BlendLighten(pixIter core.PixelIterator, calc core.PixCalculator[*image.NRGBA], compositing internal.BlendCompositing) *image.NRGBA {
	return core.Iterate(pixIter, calc, func(dst, src, out []uint8) {
		for i := 0; i < len(src); i += 4 {
			sA := uint32(src[i+3])
			dA := uint32(dst[i+3])

			if sA == 0 { // Source is transparent
				if compositing&internal.CompositeBlendAndDst != 0 {
					out[i], out[i+1], out[i+2], out[i+3] = dst[i], dst[i+1], dst[i+2], dst[i+3]
				} else {
					out[i], out[i+1], out[i+2], out[i+3] = 0, 0, 0, 0
				}
				continue
			}
			if dA == 0 { // Destination is transparent
				if compositing&internal.CompositeBlendAndSrc != 0 {
					out[i], out[i+1], out[i+2], out[i+3] = src[i], src[i+1], src[i+2], src[i+3]
				} else {
					out[i], out[i+1], out[i+2], out[i+3] = 0, 0, 0, 0
				}
				continue
			}

			// Both src and dst have some opacity.
			sR, sG, sB := uint32(src[i]), uint32(src[i+1]), uint32(src[i+2])
			dR, dG, dB := uint32(dst[i]), uint32(dst[i+1]), uint32(dst[i+2])
			var oR, oG, oB uint32

			// Calculate the pure blend color
			// region BLEND-SPECIFIC LOGIC
			oR = max(sR, dR)
			oG = max(sG, dG)
			oB = max(sB, dB)
			// endregion BLEND-SPECIFIC LOGIC

			if (sA & dA) == 255 {
				out[i], out[i+1], out[i+2], out[i+3] = uint8(oR), uint8(oG), uint8(oB), 255
				continue
			}

			var compR, compG, compB, compA, outA uint32
			switch compositing {
			case internal.CompositeAll:
				// Case 1: Show both src and dst
				invSA, invDA := 255-sA, 255-dA
				term1, term2, term3 := md255(sA, invDA), md255(dA, invSA), md255(sA, dA)

				compR = md255(term1, sR) + md255(term2, dR) + md255(term3, oR)
				compG = md255(term1, sG) + md255(term2, dG) + md255(term3, oG)
				compB = md255(term1, sB) + md255(term2, dB) + md255(term3, oB)
				compA = sA + term2
				outA = compA
			case internal.CompositeBlendAndSrc:
				// Case 2: Show src only
				invDA := 255 - dA
				term1 := md255(sA, invDA)
				compR = md255(term1, sR) + md255(dA, oR)
				compG = md255(term1, sG) + md255(dA, oG)
				compB = md255(term1, sB) + md255(dA, oB)
				compA = dA + term1
				outA = sA
			case internal.CompositeBlendAndDst:
				// Case 3: Show dst only
				invSA := 255 - sA
				term2 := md255(dA, invSA)
				compR = md255(term2, dR) + md255(sA, oR)
				compG = md255(term2, dG) + md255(sA, oG)
				compB = md255(term2, dB) + md255(sA, oB)
				compA = sA + term2
				outA = dA
			case internal.CompositeBlendOnly:
				// Case 4: Show neither (intersection only)
				oA := md255(sA, dA)
				out[i], out[i+1], out[i+2], out[i+3] = uint8(oR), uint8(oG), uint8(oB), uint8(oA)
				continue
			}

			round := compA / 2
			out[i] = uint8((compR*255 + round) / compA)
			out[i+1] = uint8((compG*255 + round) / compA)
			out[i+2] = uint8((compB*255 + round) / compA)
			out[i+3] = uint8(outA)
		}
	})
}

// BlendLinearBurn performs a "LinearBurn" blend on NRGBA images.
// Logic: Cr = Cs + Cd - 1
func BlendLinearBurn(pixIter core.PixelIterator, calc core.PixCalculator[*image.NRGBA], compositing internal.BlendCompositing) *image.NRGBA {
	return core.Iterate(pixIter, calc, func(dst, src, out []uint8) {
		for i := 0; i < len(src); i += 4 {
			sA := uint32(src[i+3])
			dA := uint32(dst[i+3])

			if sA == 0 { // Source is transparent
				if compositing&internal.CompositeBlendAndDst != 0 {
					out[i], out[i+1], out[i+2], out[i+3] = dst[i], dst[i+1], dst[i+2], dst[i+3]
				} else {
					out[i], out[i+1], out[i+2], out[i+3] = 0, 0, 0, 0
				}
				continue
			}
			if dA == 0 { // Destination is transparent
				if compositing&internal.CompositeBlendAndSrc != 0 {
					out[i], out[i+1], out[i+2], out[i+3] = src[i], src[i+1], src[i+2], src[i+3]
				} else {
					out[i], out[i+1], out[i+2], out[i+3] = 0, 0, 0, 0
				}
				continue
			}

			// Both src and dst have some opacity.
			sR, sG, sB := uint32(src[i]), uint32(src[i+1]), uint32(src[i+2])
			dR, dG, dB := uint32(dst[i]), uint32(dst[i+1]), uint32(dst[i+2])
			var oR, oG, oB uint32

			// Calculate the pure blend color
			// region BLEND-SPECIFIC LOGIC
			oR = sR + dR - 255
			if oR > 255 {
				oR = 0
			}
			oG = sG + dG - 255
			if oG > 255 {
				oG = 0
			}
			oB = sB + dB - 255
			if oB > 255 {
				oB = 0
			}
			// endregion BLEND-SPECIFIC LOGIC

			if (sA & dA) == 255 {
				out[i], out[i+1], out[i+2], out[i+3] = uint8(oR), uint8(oG), uint8(oB), 255
				continue
			}

			var compR, compG, compB, compA, outA uint32
			switch compositing {
			case internal.CompositeAll:
				// Case 1: Show both src and dst
				invSA, invDA := 255-sA, 255-dA
				term1, term2, term3 := md255(sA, invDA), md255(dA, invSA), md255(sA, dA)

				compR = md255(term1, sR) + md255(term2, dR) + md255(term3, oR)
				compG = md255(term1, sG) + md255(term2, dG) + md255(term3, oG)
				compB = md255(term1, sB) + md255(term2, dB) + md255(term3, oB)
				compA = sA + term2
				outA = compA
			case internal.CompositeBlendAndSrc:
				// Case 2: Show src only
				invDA := 255 - dA
				term1 := md255(sA, invDA)
				compR = md255(term1, sR) + md255(dA, oR)
				compG = md255(term1, sG) + md255(dA, oG)
				compB = md255(term1, sB) + md255(dA, oB)
				compA = dA + term1
				outA = sA
			case internal.CompositeBlendAndDst:
				// Case 3: Show dst only
				invSA := 255 - sA
				term2 := md255(dA, invSA)
				compR = md255(term2, dR) + md255(sA, oR)
				compG = md255(term2, dG) + md255(sA, oG)
				compB = md255(term2, dB) + md255(sA, oB)
				compA = sA + term2
				outA = dA
			case internal.CompositeBlendOnly:
				// Case 4: Show neither (intersection only)
				oA := md255(sA, dA)
				out[i], out[i+1], out[i+2], out[i+3] = uint8(oR), uint8(oG), uint8(oB), uint8(oA)
				continue
			}

			round := compA / 2
			out[i] = uint8((compR*255 + round) / compA)
			out[i+1] = uint8((compG*255 + round) / compA)
			out[i+2] = uint8((compB*255 + round) / compA)
			out[i+3] = uint8(outA)
		}
	})
}

// BlendLinearDodge performs a "LinearDodge" blend on NRGBA images.
// Logic: Cr = Cs + Cd
func BlendLinearDodge(pixIter core.PixelIterator, calc core.PixCalculator[*image.NRGBA], compositing internal.BlendCompositing) *image.NRGBA {
	return core.Iterate(pixIter, calc, func(dst, src, out []uint8) {
		for i := 0; i < len(src); i += 4 {
			sA := uint32(src[i+3])
			dA := uint32(dst[i+3])

			if sA == 0 { // Source is transparent
				if compositing&internal.CompositeBlendAndDst != 0 {
					out[i], out[i+1], out[i+2], out[i+3] = dst[i], dst[i+1], dst[i+2], dst[i+3]
				} else {
					out[i], out[i+1], out[i+2], out[i+3] = 0, 0, 0, 0
				}
				continue
			}
			if dA == 0 { // Destination is transparent
				if compositing&internal.CompositeBlendAndSrc != 0 {
					out[i], out[i+1], out[i+2], out[i+3] = src[i], src[i+1], src[i+2], src[i+3]
				} else {
					out[i], out[i+1], out[i+2], out[i+3] = 0, 0, 0, 0
				}
				continue
			}

			// Both src and dst have some opacity.
			sR, sG, sB := uint32(src[i]), uint32(src[i+1]), uint32(src[i+2])
			dR, dG, dB := uint32(dst[i]), uint32(dst[i+1]), uint32(dst[i+2])
			var oR, oG, oB uint32

			// Calculate the pure blend color
			// region BLEND-SPECIFIC LOGIC
			oR = min(sR+dR, 255)
			oG = min(sG+dG, 255)
			oB = min(sB+dB, 255)
			// endregion BLEND-SPECIFIC LOGIC

			if (sA & dA) == 255 {
				out[i], out[i+1], out[i+2], out[i+3] = uint8(oR), uint8(oG), uint8(oB), 255
				continue
			}

			var compR, compG, compB, compA, outA uint32
			switch compositing {
			case internal.CompositeAll:
				// Case 1: Show both src and dst
				invSA, invDA := 255-sA, 255-dA
				term1, term2, term3 := md255(sA, invDA), md255(dA, invSA), md255(sA, dA)

				compR = md255(term1, sR) + md255(term2, dR) + md255(term3, oR)
				compG = md255(term1, sG) + md255(term2, dG) + md255(term3, oG)
				compB = md255(term1, sB) + md255(term2, dB) + md255(term3, oB)
				compA = sA + term2
				outA = compA
			case internal.CompositeBlendAndSrc:
				// Case 2: Show src only
				invDA := 255 - dA
				term1 := md255(sA, invDA)
				compR = md255(term1, sR) + md255(dA, oR)
				compG = md255(term1, sG) + md255(dA, oG)
				compB = md255(term1, sB) + md255(dA, oB)
				compA = dA + term1
				outA = sA
			case internal.CompositeBlendAndDst:
				// Case 3: Show dst only
				invSA := 255 - sA
				term2 := md255(dA, invSA)
				compR = md255(term2, dR) + md255(sA, oR)
				compG = md255(term2, dG) + md255(sA, oG)
				compB = md255(term2, dB) + md255(sA, oB)
				compA = sA + term2
				outA = dA
			case internal.CompositeBlendOnly:
				// Case 4: Show neither (intersection only)
				oA := md255(sA, dA)
				out[i], out[i+1], out[i+2], out[i+3] = uint8(oR), uint8(oG), uint8(oB), uint8(oA)
				continue
			}

			round := compA / 2
			out[i] = uint8((compR*255 + round) / compA)
			out[i+1] = uint8((compG*255 + round) / compA)
			out[i+2] = uint8((compB*255 + round) / compA)
			out[i+3] = uint8(outA)
		}
	})
}

// BlendLinearLight performs a "LinearLight" blend on NRGBA images.
// Logic: Cr = Cd + 2*Cs - 1
func BlendLinearLight(pixIter core.PixelIterator, calc core.PixCalculator[*image.NRGBA], compositing internal.BlendCompositing) *image.NRGBA {
	return core.Iterate(pixIter, calc, func(dst, src, out []uint8) {
		for i := 0; i < len(src); i += 4 {
			sA := uint32(src[i+3])
			dA := uint32(dst[i+3])

			if sA == 0 { // Source is transparent
				if compositing&internal.CompositeBlendAndDst != 0 {
					out[i], out[i+1], out[i+2], out[i+3] = dst[i], dst[i+1], dst[i+2], dst[i+3]
				} else {
					out[i], out[i+1], out[i+2], out[i+3] = 0, 0, 0, 0
				}
				continue
			}
			if dA == 0 { // Destination is transparent
				if compositing&internal.CompositeBlendAndSrc != 0 {
					out[i], out[i+1], out[i+2], out[i+3] = src[i], src[i+1], src[i+2], src[i+3]
				} else {
					out[i], out[i+1], out[i+2], out[i+3] = 0, 0, 0, 0
				}
				continue
			}

			// Both src and dst have some opacity.
			sR, sG, sB := uint32(src[i]), uint32(src[i+1]), uint32(src[i+2])
			dR, dG, dB := uint32(dst[i]), uint32(dst[i+1]), uint32(dst[i+2])
			var oR, oG, oB uint32

			// Calculate the pure blend color
			// region BLEND-SPECIFIC LOGIC
			oR = dR + 2*sR - 255
			if oR > 510 {
				oR = 0
			} else if oR > 255 {
				oR = 255
			}
			oG = dG + 2*sG - 255
			if oG > 510 {
				oG = 0
			} else if oG > 255 {
				oG = 255
			}
			oB = dB + 2*sB - 255
			if oB > 510 {
				oB = 0
			} else if oB > 255 {
				oB = 255
			}
			// endregion BLEND-SPECIFIC LOGIC

			if (sA & dA) == 255 {
				out[i], out[i+1], out[i+2], out[i+3] = uint8(oR), uint8(oG), uint8(oB), 255
				continue
			}

			var compR, compG, compB, compA, outA uint32
			switch compositing {
			case internal.CompositeAll:
				// Case 1: Show both src and dst
				invSA, invDA := 255-sA, 255-dA
				term1, term2, term3 := md255(sA, invDA), md255(dA, invSA), md255(sA, dA)

				compR = md255(term1, sR) + md255(term2, dR) + md255(term3, oR)
				compG = md255(term1, sG) + md255(term2, dG) + md255(term3, oG)
				compB = md255(term1, sB) + md255(term2, dB) + md255(term3, oB)
				compA = sA + term2
				outA = compA
			case internal.CompositeBlendAndSrc:
				// Case 2: Show src only
				invDA := 255 - dA
				term1 := md255(sA, invDA)
				compR = md255(term1, sR) + md255(dA, oR)
				compG = md255(term1, sG) + md255(dA, oG)
				compB = md255(term1, sB) + md255(dA, oB)
				compA = dA + term1
				outA = sA
			case internal.CompositeBlendAndDst:
				// Case 3: Show dst only
				invSA := 255 - sA
				term2 := md255(dA, invSA)
				compR = md255(term2, dR) + md255(sA, oR)
				compG = md255(term2, dG) + md255(sA, oG)
				compB = md255(term2, dB) + md255(sA, oB)
				compA = sA + term2
				outA = dA
			case internal.CompositeBlendOnly:
				// Case 4: Show neither (intersection only)
				oA := md255(sA, dA)
				out[i], out[i+1], out[i+2], out[i+3] = uint8(oR), uint8(oG), uint8(oB), uint8(oA)
				continue
			}

			round := compA / 2
			out[i] = uint8((compR*255 + round) / compA)
			out[i+1] = uint8((compG*255 + round) / compA)
			out[i+2] = uint8((compB*255 + round) / compA)
			out[i+3] = uint8(outA)
		}
	})
}

// BlendMultiply performs a "Multiply" blend on NRGBA images.
// Logic: Cr = Cs * Cd
func BlendMultiply(pixIter core.PixelIterator, calc core.PixCalculator[*image.NRGBA], compositing internal.BlendCompositing) *image.NRGBA {
	return core.Iterate(pixIter, calc, func(dst, src, out []uint8) {
		for i := 0; i < len(src); i += 4 {
			sA := uint32(src[i+3])
			dA := uint32(dst[i+3])

			if sA == 0 { // Source is transparent
				if compositing&internal.CompositeBlendAndDst != 0 {
					out[i], out[i+1], out[i+2], out[i+3] = dst[i], dst[i+1], dst[i+2], dst[i+3]
				} else {
					out[i], out[i+1], out[i+2], out[i+3] = 0, 0, 0, 0
				}
				continue
			}
			if dA == 0 { // Destination is transparent
				if compositing&internal.CompositeBlendAndSrc != 0 {
					out[i], out[i+1], out[i+2], out[i+3] = src[i], src[i+1], src[i+2], src[i+3]
				} else {
					out[i], out[i+1], out[i+2], out[i+3] = 0, 0, 0, 0
				}
				continue
			}

			// Both src and dst have some opacity.
			sR, sG, sB := uint32(src[i]), uint32(src[i+1]), uint32(src[i+2])
			dR, dG, dB := uint32(dst[i]), uint32(dst[i+1]), uint32(dst[i+2])
			var oR, oG, oB uint32

			// Calculate the pure blend color
			// region BLEND-SPECIFIC LOGIC
			oR = md255(sR, dR)
			oG = md255(sG, dG)
			oB = md255(sB, dB)
			// endregion BLEND-SPECIFIC LOGIC

			if (sA & dA) == 255 {
				out[i], out[i+1], out[i+2], out[i+3] = uint8(oR), uint8(oG), uint8(oB), 255
				continue
			}

			var compR, compG, compB, compA, outA uint32
			switch compositing {
			case internal.CompositeAll:
				// Case 1: Show both src and dst
				invSA, invDA := 255-sA, 255-dA
				term1, term2, term3 := md255(sA, invDA), md255(dA, invSA), md255(sA, dA)

				compR = md255(term1, sR) + md255(term2, dR) + md255(term3, oR)
				compG = md255(term1, sG) + md255(term2, dG) + md255(term3, oG)
				compB = md255(term1, sB) + md255(term2, dB) + md255(term3, oB)
				compA = sA + term2
				outA = compA
			case internal.CompositeBlendAndSrc:
				// Case 2: Show src only
				invDA := 255 - dA
				term1 := md255(sA, invDA)
				compR = md255(term1, sR) + md255(dA, oR)
				compG = md255(term1, sG) + md255(dA, oG)
				compB = md255(term1, sB) + md255(dA, oB)
				compA = dA + term1
				outA = sA
			case internal.CompositeBlendAndDst:
				// Case 3: Show dst only
				invSA := 255 - sA
				term2 := md255(dA, invSA)
				compR = md255(term2, dR) + md255(sA, oR)
				compG = md255(term2, dG) + md255(sA, oG)
				compB = md255(term2, dB) + md255(sA, oB)
				compA = sA + term2
				outA = dA
			case internal.CompositeBlendOnly:
				// Case 4: Show neither (intersection only)
				oA := md255(sA, dA)
				out[i], out[i+1], out[i+2], out[i+3] = uint8(oR), uint8(oG), uint8(oB), uint8(oA)
				continue
			}

			round := compA / 2
			out[i] = uint8((compR*255 + round) / compA)
			out[i+1] = uint8((compG*255 + round) / compA)
			out[i+2] = uint8((compB*255 + round) / compA)
			out[i+3] = uint8(outA)
		}
	})
}

// BlendOverlay performs a "Overlay" blend on NRGBA images.
// Logic: if Cd < 0.5 { Cr = 2 * Cs * Cd } else { Cr = 1 - 2 * (1 - Cs) * (1 - Cd) }
func BlendOverlay(pixIter core.PixelIterator, calc core.PixCalculator[*image.NRGBA], compositing internal.BlendCompositing) *image.NRGBA {
	return core.Iterate(pixIter, calc, func(dst, src, out []uint8) {
		for i := 0; i < len(src); i += 4 {
			sA := uint32(src[i+3])
			dA := uint32(dst[i+3])

			if sA == 0 { // Source is transparent
				if compositing&internal.CompositeBlendAndDst != 0 {
					out[i], out[i+1], out[i+2], out[i+3] = dst[i], dst[i+1], dst[i+2], dst[i+3]
				} else {
					out[i], out[i+1], out[i+2], out[i+3] = 0, 0, 0, 0
				}
				continue
			}
			if dA == 0 { // Destination is transparent
				if compositing&internal.CompositeBlendAndSrc != 0 {
					out[i], out[i+1], out[i+2], out[i+3] = src[i], src[i+1], src[i+2], src[i+3]
				} else {
					out[i], out[i+1], out[i+2], out[i+3] = 0, 0, 0, 0
				}
				continue
			}

			// Both src and dst have some opacity.
			sR, sG, sB := uint32(src[i]), uint32(src[i+1]), uint32(src[i+2])
			dR, dG, dB := uint32(dst[i]), uint32(dst[i+1]), uint32(dst[i+2])
			var oR, oG, oB uint32

			// Calculate the pure blend color
			// region BLEND-SPECIFIC LOGIC
			if dR < 128 {
				oR = 2 * md255(sR, dR)
			} else {
				oR = 255 - 2*md255(255-sR, 255-dR)
			}
			if dG < 128 {
				oG = 2 * md255(sG, dG)
			} else {
				oG = 255 - 2*md255(255-sG, 255-dG)
			}
			if dB < 128 {
				oB = 2 * md255(sB, dB)
			} else {
				oB = 255 - 2*md255(255-sB, 255-dB)
			}
			// endregion BLEND-SPECIFIC LOGIC

			if (sA & dA) == 255 {
				out[i], out[i+1], out[i+2], out[i+3] = uint8(oR), uint8(oG), uint8(oB), 255
				continue
			}

			var compR, compG, compB, compA, outA uint32
			switch compositing {
			case internal.CompositeAll:
				// Case 1: Show both src and dst
				invSA, invDA := 255-sA, 255-dA
				term1, term2, term3 := md255(sA, invDA), md255(dA, invSA), md255(sA, dA)

				compR = md255(term1, sR) + md255(term2, dR) + md255(term3, oR)
				compG = md255(term1, sG) + md255(term2, dG) + md255(term3, oG)
				compB = md255(term1, sB) + md255(term2, dB) + md255(term3, oB)
				compA = sA + term2
				outA = compA
			case internal.CompositeBlendAndSrc:
				// Case 2: Show src only
				invDA := 255 - dA
				term1 := md255(sA, invDA)
				compR = md255(term1, sR) + md255(dA, oR)
				compG = md255(term1, sG) + md255(dA, oG)
				compB = md255(term1, sB) + md255(dA, oB)
				compA = dA + term1
				outA = sA
			case internal.CompositeBlendAndDst:
				// Case 3: Show dst only
				invSA := 255 - sA
				term2 := md255(dA, invSA)
				compR = md255(term2, dR) + md255(sA, oR)
				compG = md255(term2, dG) + md255(sA, oG)
				compB = md255(term2, dB) + md255(sA, oB)
				compA = sA + term2
				outA = dA
			case internal.CompositeBlendOnly:
				// Case 4: Show neither (intersection only)
				oA := md255(sA, dA)
				out[i], out[i+1], out[i+2], out[i+3] = uint8(oR), uint8(oG), uint8(oB), uint8(oA)
				continue
			}

			round := compA / 2
			out[i] = uint8((compR*255 + round) / compA)
			out[i+1] = uint8((compG*255 + round) / compA)
			out[i+2] = uint8((compB*255 + round) / compA)
			out[i+3] = uint8(outA)
		}
	})
}

// BlendPinLight performs a "PinLight" blend on NRGBA images.
// Logic: if Cs < 0.5 { Cr = min(Cd, 2 * Cs) } else { Cr = max(Cd, 2 * Cs - 1) }
func BlendPinLight(pixIter core.PixelIterator, calc core.PixCalculator[*image.NRGBA], compositing internal.BlendCompositing) *image.NRGBA {
	return core.Iterate(pixIter, calc, func(dst, src, out []uint8) {
		for i := 0; i < len(src); i += 4 {
			sA := uint32(src[i+3])
			dA := uint32(dst[i+3])

			if sA == 0 { // Source is transparent
				if compositing&internal.CompositeBlendAndDst != 0 {
					out[i], out[i+1], out[i+2], out[i+3] = dst[i], dst[i+1], dst[i+2], dst[i+3]
				} else {
					out[i], out[i+1], out[i+2], out[i+3] = 0, 0, 0, 0
				}
				continue
			}
			if dA == 0 { // Destination is transparent
				if compositing&internal.CompositeBlendAndSrc != 0 {
					out[i], out[i+1], out[i+2], out[i+3] = src[i], src[i+1], src[i+2], src[i+3]
				} else {
					out[i], out[i+1], out[i+2], out[i+3] = 0, 0, 0, 0
				}
				continue
			}

			// Both src and dst have some opacity.
			sR, sG, sB := uint32(src[i]), uint32(src[i+1]), uint32(src[i+2])
			dR, dG, dB := uint32(dst[i]), uint32(dst[i+1]), uint32(dst[i+2])
			var oR, oG, oB uint32

			// Calculate the pure blend color
			// region BLEND-SPECIFIC LOGIC
			if sR < 128 {
				oR = min(dR, 2*sR)
			} else {
				oR = max(dR, 2*sR-255)
			}
			if sG < 128 {
				oG = min(dG, 2*sG)
			} else {
				oG = max(dG, 2*sG-255)
			}
			if sB < 128 {
				oB = min(dB, 2*sB)
			} else {
				oB = max(dB, 2*sB-255)
			}
			// endregion BLEND-SPECIFIC LOGIC

			if (sA & dA) == 255 {
				out[i], out[i+1], out[i+2], out[i+3] = uint8(oR), uint8(oG), uint8(oB), 255
				continue
			}

			var compR, compG, compB, compA, outA uint32
			switch compositing {
			case internal.CompositeAll:
				// Case 1: Show both src and dst
				invSA, invDA := 255-sA, 255-dA
				term1, term2, term3 := md255(sA, invDA), md255(dA, invSA), md255(sA, dA)

				compR = md255(term1, sR) + md255(term2, dR) + md255(term3, oR)
				compG = md255(term1, sG) + md255(term2, dG) + md255(term3, oG)
				compB = md255(term1, sB) + md255(term2, dB) + md255(term3, oB)
				compA = sA + term2
				outA = compA
			case internal.CompositeBlendAndSrc:
				// Case 2: Show src only
				invDA := 255 - dA
				term1 := md255(sA, invDA)
				compR = md255(term1, sR) + md255(dA, oR)
				compG = md255(term1, sG) + md255(dA, oG)
				compB = md255(term1, sB) + md255(dA, oB)
				compA = dA + term1
				outA = sA
			case internal.CompositeBlendAndDst:
				// Case 3: Show dst only
				invSA := 255 - sA
				term2 := md255(dA, invSA)
				compR = md255(term2, dR) + md255(sA, oR)
				compG = md255(term2, dG) + md255(sA, oG)
				compB = md255(term2, dB) + md255(sA, oB)
				compA = sA + term2
				outA = dA
			case internal.CompositeBlendOnly:
				// Case 4: Show neither (intersection only)
				oA := md255(sA, dA)
				out[i], out[i+1], out[i+2], out[i+3] = uint8(oR), uint8(oG), uint8(oB), uint8(oA)
				continue
			}

			round := compA / 2
			out[i] = uint8((compR*255 + round) / compA)
			out[i+1] = uint8((compG*255 + round) / compA)
			out[i+2] = uint8((compB*255 + round) / compA)
			out[i+3] = uint8(outA)
		}
	})
}

// BlendScreen performs a "Screen" blend on NRGBA images.
// Logic: Cr = 1 - (1 - Cs) * (1 - Cd)
func BlendScreen(pixIter core.PixelIterator, calc core.PixCalculator[*image.NRGBA], compositing internal.BlendCompositing) *image.NRGBA {
	return core.Iterate(pixIter, calc, func(dst, src, out []uint8) {
		for i := 0; i < len(src); i += 4 {
			sA := uint32(src[i+3])
			dA := uint32(dst[i+3])

			if sA == 0 { // Source is transparent
				if compositing&internal.CompositeBlendAndDst != 0 {
					out[i], out[i+1], out[i+2], out[i+3] = dst[i], dst[i+1], dst[i+2], dst[i+3]
				} else {
					out[i], out[i+1], out[i+2], out[i+3] = 0, 0, 0, 0
				}
				continue
			}
			if dA == 0 { // Destination is transparent
				if compositing&internal.CompositeBlendAndSrc != 0 {
					out[i], out[i+1], out[i+2], out[i+3] = src[i], src[i+1], src[i+2], src[i+3]
				} else {
					out[i], out[i+1], out[i+2], out[i+3] = 0, 0, 0, 0
				}
				continue
			}

			// Both src and dst have some opacity.
			sR, sG, sB := uint32(src[i]), uint32(src[i+1]), uint32(src[i+2])
			dR, dG, dB := uint32(dst[i]), uint32(dst[i+1]), uint32(dst[i+2])
			var oR, oG, oB uint32

			// Calculate the pure blend color
			// region BLEND-SPECIFIC LOGIC
			oR = 255 - md255(255-sR, 255-dR)
			oG = 255 - md255(255-sG, 255-dG)
			oB = 255 - md255(255-sB, 255-dB)
			// endregion BLEND-SPECIFIC LOGIC

			if (sA & dA) == 255 {
				out[i], out[i+1], out[i+2], out[i+3] = uint8(oR), uint8(oG), uint8(oB), 255
				continue
			}

			var compR, compG, compB, compA, outA uint32
			switch compositing {
			case internal.CompositeAll:
				// Case 1: Show both src and dst
				invSA, invDA := 255-sA, 255-dA
				term1, term2, term3 := md255(sA, invDA), md255(dA, invSA), md255(sA, dA)

				compR = md255(term1, sR) + md255(term2, dR) + md255(term3, oR)
				compG = md255(term1, sG) + md255(term2, dG) + md255(term3, oG)
				compB = md255(term1, sB) + md255(term2, dB) + md255(term3, oB)
				compA = sA + term2
				outA = compA
			case internal.CompositeBlendAndSrc:
				// Case 2: Show src only
				invDA := 255 - dA
				term1 := md255(sA, invDA)
				compR = md255(term1, sR) + md255(dA, oR)
				compG = md255(term1, sG) + md255(dA, oG)
				compB = md255(term1, sB) + md255(dA, oB)
				compA = dA + term1
				outA = sA
			case internal.CompositeBlendAndDst:
				// Case 3: Show dst only
				invSA := 255 - sA
				term2 := md255(dA, invSA)
				compR = md255(term2, dR) + md255(sA, oR)
				compG = md255(term2, dG) + md255(sA, oG)
				compB = md255(term2, dB) + md255(sA, oB)
				compA = sA + term2
				outA = dA
			case internal.CompositeBlendOnly:
				// Case 4: Show neither (intersection only)
				oA := md255(sA, dA)
				out[i], out[i+1], out[i+2], out[i+3] = uint8(oR), uint8(oG), uint8(oB), uint8(oA)
				continue
			}

			round := compA / 2
			out[i] = uint8((compR*255 + round) / compA)
			out[i+1] = uint8((compG*255 + round) / compA)
			out[i+2] = uint8((compB*255 + round) / compA)
			out[i+3] = uint8(outA)
		}
	})
}

// BlendSoftLight performs a "SoftLight" blend on NRGBA images.
// Logic: if Cs < 0.5 { Cr = Cd - (1 - 2*Cs) * Cd * (1 - Cd) } else { Cr = Cd + (2*Cs - 1) * (sqrt(Cd) - Cd) }
func BlendSoftLight(pixIter core.PixelIterator, calc core.PixCalculator[*image.NRGBA], compositing internal.BlendCompositing) *image.NRGBA {
	return core.Iterate(pixIter, calc, func(dst, src, out []uint8) {
		for i := 0; i < len(src); i += 4 {
			sA := uint32(src[i+3])
			dA := uint32(dst[i+3])

			if sA == 0 { // Source is transparent
				if compositing&internal.CompositeBlendAndDst != 0 {
					out[i], out[i+1], out[i+2], out[i+3] = dst[i], dst[i+1], dst[i+2], dst[i+3]
				} else {
					out[i], out[i+1], out[i+2], out[i+3] = 0, 0, 0, 0
				}
				continue
			}
			if dA == 0 { // Destination is transparent
				if compositing&internal.CompositeBlendAndSrc != 0 {
					out[i], out[i+1], out[i+2], out[i+3] = src[i], src[i+1], src[i+2], src[i+3]
				} else {
					out[i], out[i+1], out[i+2], out[i+3] = 0, 0, 0, 0
				}
				continue
			}

			// Both src and dst have some opacity.
			sR, sG, sB := uint32(src[i]), uint32(src[i+1]), uint32(src[i+2])
			dR, dG, dB := uint32(dst[i]), uint32(dst[i+1]), uint32(dst[i+2])
			var oR, oG, oB uint32

			// Calculate the pure blend color
			// region BLEND-SPECIFIC LOGIC
			if sR < 128 {
				oR = dR - div255(div255((255-2*sR)*dR*(255-dR)))
			} else {
				oR = dR + md255(2*sR-255, sqrt(dR)-dR)
			}
			if sG < 128 {
				oG = dG - div255(div255((255-2*sG)*dG*(255-dG)))
			} else {
				oG = dG + md255(2*sG-255, sqrt(dG)-dG)
			}
			if sB < 128 {
				oB = dB - div255(div255((255-2*sB)*dB*(255-dB)))
			} else {
				oB = dB + md255(2*sB-255, sqrt(dB)-dB)
			}
			// endregion BLEND-SPECIFIC LOGIC

			if (sA & dA) == 255 {
				out[i], out[i+1], out[i+2], out[i+3] = uint8(oR), uint8(oG), uint8(oB), 255
				continue
			}

			var compR, compG, compB, compA, outA uint32
			switch compositing {
			case internal.CompositeAll:
				// Case 1: Show both src and dst
				invSA, invDA := 255-sA, 255-dA
				term1, term2, term3 := md255(sA, invDA), md255(dA, invSA), md255(sA, dA)

				compR = md255(term1, sR) + md255(term2, dR) + md255(term3, oR)
				compG = md255(term1, sG) + md255(term2, dG) + md255(term3, oG)
				compB = md255(term1, sB) + md255(term2, dB) + md255(term3, oB)
				compA = sA + term2
				outA = compA
			case internal.CompositeBlendAndSrc:
				// Case 2: Show src only
				invDA := 255 - dA
				term1 := md255(sA, invDA)
				compR = md255(term1, sR) + md255(dA, oR)
				compG = md255(term1, sG) + md255(dA, oG)
				compB = md255(term1, sB) + md255(dA, oB)
				compA = dA + term1
				outA = sA
			case internal.CompositeBlendAndDst:
				// Case 3: Show dst only
				invSA := 255 - sA
				term2 := md255(dA, invSA)
				compR = md255(term2, dR) + md255(sA, oR)
				compG = md255(term2, dG) + md255(sA, oG)
				compB = md255(term2, dB) + md255(sA, oB)
				compA = sA + term2
				outA = dA
			case internal.CompositeBlendOnly:
				// Case 4: Show neither (intersection only)
				oA := md255(sA, dA)
				out[i], out[i+1], out[i+2], out[i+3] = uint8(oR), uint8(oG), uint8(oB), uint8(oA)
				continue
			}

			round := compA / 2
			out[i] = uint8((compR*255 + round) / compA)
			out[i+1] = uint8((compG*255 + round) / compA)
			out[i+2] = uint8((compB*255 + round) / compA)
			out[i+3] = uint8(outA)
		}
	})
}

// BlendSubtract performs a "Subtract" blend on NRGBA images.
// Logic: Cr = Cd - Cs
func BlendSubtract(pixIter core.PixelIterator, calc core.PixCalculator[*image.NRGBA], compositing internal.BlendCompositing) *image.NRGBA {
	return core.Iterate(pixIter, calc, func(dst, src, out []uint8) {
		for i := 0; i < len(src); i += 4 {
			sA := uint32(src[i+3])
			dA := uint32(dst[i+3])

			if sA == 0 { // Source is transparent
				if compositing&internal.CompositeBlendAndDst != 0 {
					out[i], out[i+1], out[i+2], out[i+3] = dst[i], dst[i+1], dst[i+2], dst[i+3]
				} else {
					out[i], out[i+1], out[i+2], out[i+3] = 0, 0, 0, 0
				}
				continue
			}
			if dA == 0 { // Destination is transparent
				if compositing&internal.CompositeBlendAndSrc != 0 {
					out[i], out[i+1], out[i+2], out[i+3] = src[i], src[i+1], src[i+2], src[i+3]
				} else {
					out[i], out[i+1], out[i+2], out[i+3] = 0, 0, 0, 0
				}
				continue
			}

			// Both src and dst have some opacity.
			sR, sG, sB := uint32(src[i]), uint32(src[i+1]), uint32(src[i+2])
			dR, dG, dB := uint32(dst[i]), uint32(dst[i+1]), uint32(dst[i+2])
			var oR, oG, oB uint32

			// Calculate the pure blend color
			// region BLEND-SPECIFIC LOGIC
			oR = uint32(max(int(dR)-int(sR), 0))
			oG = uint32(max(int(dG)-int(sG), 0))
			oB = uint32(max(int(dB)-int(sB), 0))
			// endregion BLEND-SPECIFIC LOGIC

			if (sA & dA) == 255 {
				out[i], out[i+1], out[i+2], out[i+3] = uint8(oR), uint8(oG), uint8(oB), 255
				continue
			}

			var compR, compG, compB, compA, outA uint32
			switch compositing {
			case internal.CompositeAll:
				// Case 1: Show both src and dst
				invSA, invDA := 255-sA, 255-dA
				term1, term2, term3 := md255(sA, invDA), md255(dA, invSA), md255(sA, dA)

				compR = md255(term1, sR) + md255(term2, dR) + md255(term3, oR)
				compG = md255(term1, sG) + md255(term2, dG) + md255(term3, oG)
				compB = md255(term1, sB) + md255(term2, dB) + md255(term3, oB)
				compA = sA + term2
				outA = compA
			case internal.CompositeBlendAndSrc:
				// Case 2: Show src only
				invDA := 255 - dA
				term1 := md255(sA, invDA)
				compR = md255(term1, sR) + md255(dA, oR)
				compG = md255(term1, sG) + md255(dA, oG)
				compB = md255(term1, sB) + md255(dA, oB)
				compA = dA + term1
				outA = sA
			case internal.CompositeBlendAndDst:
				// Case 3: Show dst only
				invSA := 255 - sA
				term2 := md255(dA, invSA)
				compR = md255(term2, dR) + md255(sA, oR)
				compG = md255(term2, dG) + md255(sA, oG)
				compB = md255(term2, dB) + md255(sA, oB)
				compA = sA + term2
				outA = dA
			case internal.CompositeBlendOnly:
				// Case 4: Show neither (intersection only)
				oA := md255(sA, dA)
				out[i], out[i+1], out[i+2], out[i+3] = uint8(oR), uint8(oG), uint8(oB), uint8(oA)
				continue
			}

			round := compA / 2
			out[i] = uint8((compR*255 + round) / compA)
			out[i+1] = uint8((compG*255 + round) / compA)
			out[i+2] = uint8((compB*255 + round) / compA)
			out[i+3] = uint8(outA)
		}
	})
}

// BlendVividLight performs a "VividLight" blend on NRGBA images.
// Logic: if Cs < 0.5 { Cr = 1 - (1 - Cd) / (2 * Cs) } else { Cr = Cd / (2 * (1 - Cs)) }
func BlendVividLight(pixIter core.PixelIterator, calc core.PixCalculator[*image.NRGBA], compositing internal.BlendCompositing) *image.NRGBA {
	return core.Iterate(pixIter, calc, func(dst, src, out []uint8) {
		for i := 0; i < len(src); i += 4 {
			sA := uint32(src[i+3])
			dA := uint32(dst[i+3])

			if sA == 0 { // Source is transparent
				if compositing&internal.CompositeBlendAndDst != 0 {
					out[i], out[i+1], out[i+2], out[i+3] = dst[i], dst[i+1], dst[i+2], dst[i+3]
				} else {
					out[i], out[i+1], out[i+2], out[i+3] = 0, 0, 0, 0
				}
				continue
			}
			if dA == 0 { // Destination is transparent
				if compositing&internal.CompositeBlendAndSrc != 0 {
					out[i], out[i+1], out[i+2], out[i+3] = src[i], src[i+1], src[i+2], src[i+3]
				} else {
					out[i], out[i+1], out[i+2], out[i+3] = 0, 0, 0, 0
				}
				continue
			}

			// Both src and dst have some opacity.
			sR, sG, sB := uint32(src[i]), uint32(src[i+1]), uint32(src[i+2])
			dR, dG, dB := uint32(dst[i]), uint32(dst[i+1]), uint32(dst[i+2])
			var oR, oG, oB uint32

			// Calculate the pure blend color
			// region BLEND-SPECIFIC LOGIC
			switch {
			case sR == 0 || sR == 255:
				oR = sR
			case sR < 128:
				oR = 255 - min(((255-dR)*255+sR)/(2*sR), 255)
			default:
				oR = min(((dR*255)+(255-sR))/(510-2*sR), 255)
			}
			switch {
			case sG == 0 || sG == 255:
				oG = sG
			case sG < 128:
				oG = 255 - min(((255-dG)*255+sG)/(2*sG), 255)
			default:
				oG = min(((dG*255)+(255-sG))/(510-2*sG), 255)
			}
			switch {
			case sB == 0 || sB == 255:
				oB = sB
			case sB < 128:
				oB = 255 - min(((255-dB)*255+sB)/(2*sB), 255)
			default:
				oB = min(((dB*255)+(255-sB))/(510-2*sB), 255)
			}
			// endregion BLEND-SPECIFIC LOGIC

			if (sA & dA) == 255 {
				out[i], out[i+1], out[i+2], out[i+3] = uint8(oR), uint8(oG), uint8(oB), 255
				continue
			}

			var compR, compG, compB, compA, outA uint32
			switch compositing {
			case internal.CompositeAll:
				// Case 1: Show both src and dst
				invSA, invDA := 255-sA, 255-dA
				term1, term2, term3 := md255(sA, invDA), md255(dA, invSA), md255(sA, dA)

				compR = md255(term1, sR) + md255(term2, dR) + md255(term3, oR)
				compG = md255(term1, sG) + md255(term2, dG) + md255(term3, oG)
				compB = md255(term1, sB) + md255(term2, dB) + md255(term3, oB)
				compA = sA + term2
				outA = compA
			case internal.CompositeBlendAndSrc:
				// Case 2: Show src only
				invDA := 255 - dA
				term1 := md255(sA, invDA)
				compR = md255(term1, sR) + md255(dA, oR)
				compG = md255(term1, sG) + md255(dA, oG)
				compB = md255(term1, sB) + md255(dA, oB)
				compA = dA + term1
				outA = sA
			case internal.CompositeBlendAndDst:
				// Case 3: Show dst only
				invSA := 255 - sA
				term2 := md255(dA, invSA)
				compR = md255(term2, dR) + md255(sA, oR)
				compG = md255(term2, dG) + md255(sA, oG)
				compB = md255(term2, dB) + md255(sA, oB)
				compA = sA + term2
				outA = dA
			case internal.CompositeBlendOnly:
				// Case 4: Show neither (intersection only)
				oA := md255(sA, dA)
				out[i], out[i+1], out[i+2], out[i+3] = uint8(oR), uint8(oG), uint8(oB), uint8(oA)
				continue
			}

			round := compA / 2
			out[i] = uint8((compR*255 + round) / compA)
			out[i+1] = uint8((compG*255 + round) / compA)
			out[i+2] = uint8((compB*255 + round) / compA)
			out[i+3] = uint8(outA)
		}
	})
}
