// Code generated by go generate; DO NOT EDIT.

// Copyright 2025 Magpie Contributors
// SPDX-License-Identifier: MIT

package rgba

import (
	"image"

	"github.com/blazeroni/magpie/pkg/core"
	"github.com/blazeroni/magpie/pkg/internal"
)

// BlendColorBurn performs a 'ColorBurn' blend on RGBA images.
// Logic: Cr = 1 - (1 - Cd) / Cs
func BlendColorBurn(pixIter core.PixelIterator, calc core.PixCalculator[*image.RGBA], compositing internal.BlendCompositing) *image.RGBA {
	return core.Iterate(pixIter, calc, func(dst, src, out []uint8) {
		for i := 0; i < len(src); i += 4 {
			sA := uint32(src[i+3])
			dA := uint32(dst[i+3])

			if sA == 0 {
				if compositing&internal.CompositeBlendAndDst != 0 {
					out[i], out[i+1], out[i+2], out[i+3] = dst[i], dst[i+1], dst[i+2], dst[i+3]
				} else {
					out[i], out[i+1], out[i+2], out[i+3] = 0, 0, 0, 0
				}
				continue
			}
			if dA == 0 {
				if compositing&internal.CompositeBlendAndSrc != 0 {
					out[i], out[i+1], out[i+2], out[i+3] = src[i], src[i+1], src[i+2], src[i+3]
				} else {
					out[i], out[i+1], out[i+2], out[i+3] = 0, 0, 0, 0
				}
				continue
			}

			// pre-multiplied source & destination colors
			sR, sG, sB := uint32(src[i]), uint32(src[i+1]), uint32(src[i+2])
			dR, dG, dB := uint32(dst[i]), uint32(dst[i+1]), uint32(dst[i+2])

			if (sA & dA) == 255 {
				// un-premultiplied kernel color results
				var kR, kG, kB uint32

				// region BLEND-SPECIFIC KERNEL LOGIC
				if sR+dR <= 255 {
					kR = 0
				} else {
					kR = 255 - ((255-dR)*255+sR/2)/sR
				}
				if sG+dG <= 255 {
					kG = 0
				} else {
					kG = 255 - ((255-dG)*255+sG/2)/sG
				}
				if sB+dB <= 255 {
					kB = 0
				} else {
					kB = 255 - ((255-dB)*255+sB/2)/sB
				}
				out[i] = uint8(kR)
				out[i+1] = uint8(kG)
				out[i+2] = uint8(kB)
				// endregion BLEND-SPECIFIC KERNEL LOGIC
				out[i+3] = uint8(255)
				continue
			}

			// final output colors & alpha
			var oRp, oGp, oBp, oA uint32
			{
				// Fallback path for other compositions, or for blend modes without a direct equation.
				// This path is accurate but slower as it must un-premultiply.
				sR = unpremultiply(sR, sA)
				sG = unpremultiply(sG, sA)
				sB = unpremultiply(sB, sA)

				dR = unpremultiply(dR, dA)
				dG = unpremultiply(dG, dA)
				dB = unpremultiply(dB, dA)

				// un-premultiplied kernel color results
				var kR, kG, kB uint32

				// region BLEND-SPECIFIC KERNEL LOGIC
				if sR+dR <= 255 {
					kR = 0
				} else {
					kR = 255 - ((255-dR)*255+sR/2)/sR
				}
				if sG+dG <= 255 {
					kG = 0
				} else {
					kG = 255 - ((255-dG)*255+sG/2)/sG
				}
				if sB+dB <= 255 {
					kB = 0
				} else {
					kB = 255 - ((255-dB)*255+sB/2)/sB
				}
				// endregion BLEND-SPECIFIC KERNEL LOGIC

				// premultiplied compositing color results
				var cRp, cGp, cBp, cA uint32

				// un-premultiplied output colors
				var oRu, oGu, oBu uint32

				switch compositing {
				case internal.CompositeAll:
					invSA, invDA := 255-sA, 255-dA
					term1, term2, term3 := md255(sA, invDA), md255(dA, invSA), md255(sA, dA)

					cRp = md255(term1, sR) + md255(term2, dR) + md255(term3, kR)
					cGp = md255(term1, sG) + md255(term2, dG) + md255(term3, kG)
					cBp = md255(term1, sB) + md255(term2, dB) + md255(term3, kB)
					cA = sA + term2

					oRu = (cRp*255 + cA/2) / cA
					oGu = (cGp*255 + cA/2) / cA
					oBu = (cBp*255 + cA/2) / cA
					oA = cA
				case internal.CompositeBlendAndSrc:
					cRp = md255(md255(sA, 255-dA), sR) + md255(dA, kR)
					cGp = md255(md255(sA, 255-dA), sG) + md255(dA, kG)
					cBp = md255(md255(sA, 255-dA), sB) + md255(dA, kB)
					cA = dA + md255(sA, 255-dA)

					oRu = (cRp*255 + cA/2) / cA
					oGu = (cGp*255 + cA/2) / cA
					oBu = (cBp*255 + cA/2) / cA
					oA = sA
				case internal.CompositeBlendAndDst:
					cRp = md255(md255(dA, 255-sA), dR) + md255(sA, kR)
					cGp = md255(md255(dA, 255-sA), dG) + md255(sA, kG)
					cBp = md255(md255(dA, 255-sA), dB) + md255(sA, kB)
					cA = sA + md255(dA, 255-sA)

					oRu = (cRp*255 + cA/2) / cA
					oGu = (cGp*255 + cA/2) / cA
					oBu = (cBp*255 + cA/2) / cA
					oA = dA
				case internal.CompositeBlendOnly:
					oRu, oGu, oBu = kR, kG, kB
					oA = md255(sA, dA)
				}

				oRp = md255(oRu, oA)
				oGp = md255(oGu, oA)
				oBp = md255(oBu, oA)
			}

			out[i] = uint8(oRp)
			out[i+1] = uint8(oGp)
			out[i+2] = uint8(oBp)
			out[i+3] = uint8(oA)
		}
	})
}

// BlendColorDodge performs a 'ColorDodge' blend on RGBA images.
// Logic: Cr = Cd / (1 - Cs)
func BlendColorDodge(pixIter core.PixelIterator, calc core.PixCalculator[*image.RGBA], compositing internal.BlendCompositing) *image.RGBA {
	return core.Iterate(pixIter, calc, func(dst, src, out []uint8) {
		for i := 0; i < len(src); i += 4 {
			sA := uint32(src[i+3])
			dA := uint32(dst[i+3])

			if sA == 0 {
				if compositing&internal.CompositeBlendAndDst != 0 {
					out[i], out[i+1], out[i+2], out[i+3] = dst[i], dst[i+1], dst[i+2], dst[i+3]
				} else {
					out[i], out[i+1], out[i+2], out[i+3] = 0, 0, 0, 0
				}
				continue
			}
			if dA == 0 {
				if compositing&internal.CompositeBlendAndSrc != 0 {
					out[i], out[i+1], out[i+2], out[i+3] = src[i], src[i+1], src[i+2], src[i+3]
				} else {
					out[i], out[i+1], out[i+2], out[i+3] = 0, 0, 0, 0
				}
				continue
			}

			// pre-multiplied source & destination colors
			sR, sG, sB := uint32(src[i]), uint32(src[i+1]), uint32(src[i+2])
			dR, dG, dB := uint32(dst[i]), uint32(dst[i+1]), uint32(dst[i+2])

			if (sA & dA) == 255 {
				// un-premultiplied kernel color results
				var kR, kG, kB uint32

				// region BLEND-SPECIFIC KERNEL LOGIC
				if sR == 255 {
					kR = 255
				} else {
					kR = min((dR*255)/(255-sR), 255)
				}
				if sG == 255 {
					kG = 255
				} else {
					kG = min((dG*255)/(255-sG), 255)
				}
				if sB == 255 {
					kB = 255
				} else {
					kB = min((dB*255)/(255-sB), 255)
				}
				out[i] = uint8(kR)
				out[i+1] = uint8(kG)
				out[i+2] = uint8(kB)
				// endregion BLEND-SPECIFIC KERNEL LOGIC
				out[i+3] = uint8(255)
				continue
			}

			// final output colors & alpha
			var oRp, oGp, oBp, oA uint32
			{
				// Fallback path for other compositions, or for blend modes without a direct equation.
				// This path is accurate but slower as it must un-premultiply.
				sR = unpremultiply(sR, sA)
				sG = unpremultiply(sG, sA)
				sB = unpremultiply(sB, sA)

				dR = unpremultiply(dR, dA)
				dG = unpremultiply(dG, dA)
				dB = unpremultiply(dB, dA)

				// un-premultiplied kernel color results
				var kR, kG, kB uint32

				// region BLEND-SPECIFIC KERNEL LOGIC
				if sR == 255 {
					kR = 255
				} else {
					kR = min((dR*255)/(255-sR), 255)
				}
				if sG == 255 {
					kG = 255
				} else {
					kG = min((dG*255)/(255-sG), 255)
				}
				if sB == 255 {
					kB = 255
				} else {
					kB = min((dB*255)/(255-sB), 255)
				}
				// endregion BLEND-SPECIFIC KERNEL LOGIC

				// premultiplied compositing color results
				var cRp, cGp, cBp, cA uint32

				// un-premultiplied output colors
				var oRu, oGu, oBu uint32

				switch compositing {
				case internal.CompositeAll:
					invSA, invDA := 255-sA, 255-dA
					term1, term2, term3 := md255(sA, invDA), md255(dA, invSA), md255(sA, dA)

					cRp = md255(term1, sR) + md255(term2, dR) + md255(term3, kR)
					cGp = md255(term1, sG) + md255(term2, dG) + md255(term3, kG)
					cBp = md255(term1, sB) + md255(term2, dB) + md255(term3, kB)
					cA = sA + term2

					oRu = (cRp*255 + cA/2) / cA
					oGu = (cGp*255 + cA/2) / cA
					oBu = (cBp*255 + cA/2) / cA
					oA = cA
				case internal.CompositeBlendAndSrc:
					cRp = md255(md255(sA, 255-dA), sR) + md255(dA, kR)
					cGp = md255(md255(sA, 255-dA), sG) + md255(dA, kG)
					cBp = md255(md255(sA, 255-dA), sB) + md255(dA, kB)
					cA = dA + md255(sA, 255-dA)

					oRu = (cRp*255 + cA/2) / cA
					oGu = (cGp*255 + cA/2) / cA
					oBu = (cBp*255 + cA/2) / cA
					oA = sA
				case internal.CompositeBlendAndDst:
					cRp = md255(md255(dA, 255-sA), dR) + md255(sA, kR)
					cGp = md255(md255(dA, 255-sA), dG) + md255(sA, kG)
					cBp = md255(md255(dA, 255-sA), dB) + md255(sA, kB)
					cA = sA + md255(dA, 255-sA)

					oRu = (cRp*255 + cA/2) / cA
					oGu = (cGp*255 + cA/2) / cA
					oBu = (cBp*255 + cA/2) / cA
					oA = dA
				case internal.CompositeBlendOnly:
					oRu, oGu, oBu = kR, kG, kB
					oA = md255(sA, dA)
				}

				oRp = md255(oRu, oA)
				oGp = md255(oGu, oA)
				oBp = md255(oBu, oA)
			}

			out[i] = uint8(oRp)
			out[i+1] = uint8(oGp)
			out[i+2] = uint8(oBp)
			out[i+3] = uint8(oA)
		}
	})
}

// BlendDarken performs a 'Darken' blend on RGBA images.
// Logic: Cr = min(Cs, Cd)
func BlendDarken(pixIter core.PixelIterator, calc core.PixCalculator[*image.RGBA], compositing internal.BlendCompositing) *image.RGBA {
	return core.Iterate(pixIter, calc, func(dst, src, out []uint8) {
		for i := 0; i < len(src); i += 4 {
			sA := uint32(src[i+3])
			dA := uint32(dst[i+3])

			if sA == 0 {
				if compositing&internal.CompositeBlendAndDst != 0 {
					out[i], out[i+1], out[i+2], out[i+3] = dst[i], dst[i+1], dst[i+2], dst[i+3]
				} else {
					out[i], out[i+1], out[i+2], out[i+3] = 0, 0, 0, 0
				}
				continue
			}
			if dA == 0 {
				if compositing&internal.CompositeBlendAndSrc != 0 {
					out[i], out[i+1], out[i+2], out[i+3] = src[i], src[i+1], src[i+2], src[i+3]
				} else {
					out[i], out[i+1], out[i+2], out[i+3] = 0, 0, 0, 0
				}
				continue
			}

			// pre-multiplied source & destination colors
			sR, sG, sB := uint32(src[i]), uint32(src[i+1]), uint32(src[i+2])
			dR, dG, dB := uint32(dst[i]), uint32(dst[i+1]), uint32(dst[i+2])

			if (sA & dA) == 255 {
				// un-premultiplied kernel color results
				var kR, kG, kB uint32

				// region BLEND-SPECIFIC KERNEL LOGIC
				kR = min(sR, dR)
				kG = min(sG, dG)
				kB = min(sB, dB)
				out[i] = uint8(kR)
				out[i+1] = uint8(kG)
				out[i+2] = uint8(kB)
				// endregion BLEND-SPECIFIC KERNEL LOGIC
				out[i+3] = uint8(255)
				continue
			}

			// final output colors & alpha
			var oRp, oGp, oBp, oA uint32
			{
				// Fallback path for other compositions, or for blend modes without a direct equation.
				// This path is accurate but slower as it must un-premultiply.
				sR = unpremultiply(sR, sA)
				sG = unpremultiply(sG, sA)
				sB = unpremultiply(sB, sA)

				dR = unpremultiply(dR, dA)
				dG = unpremultiply(dG, dA)
				dB = unpremultiply(dB, dA)

				// un-premultiplied kernel color results
				var kR, kG, kB uint32

				// region BLEND-SPECIFIC KERNEL LOGIC
				kR = min(sR, dR)
				kG = min(sG, dG)
				kB = min(sB, dB)
				// endregion BLEND-SPECIFIC KERNEL LOGIC

				// premultiplied compositing color results
				var cRp, cGp, cBp, cA uint32

				// un-premultiplied output colors
				var oRu, oGu, oBu uint32

				switch compositing {
				case internal.CompositeAll:
					invSA, invDA := 255-sA, 255-dA
					term1, term2, term3 := md255(sA, invDA), md255(dA, invSA), md255(sA, dA)

					cRp = md255(term1, sR) + md255(term2, dR) + md255(term3, kR)
					cGp = md255(term1, sG) + md255(term2, dG) + md255(term3, kG)
					cBp = md255(term1, sB) + md255(term2, dB) + md255(term3, kB)
					cA = sA + term2

					oRu = (cRp*255 + cA/2) / cA
					oGu = (cGp*255 + cA/2) / cA
					oBu = (cBp*255 + cA/2) / cA
					oA = cA
				case internal.CompositeBlendAndSrc:
					cRp = md255(md255(sA, 255-dA), sR) + md255(dA, kR)
					cGp = md255(md255(sA, 255-dA), sG) + md255(dA, kG)
					cBp = md255(md255(sA, 255-dA), sB) + md255(dA, kB)
					cA = dA + md255(sA, 255-dA)

					oRu = (cRp*255 + cA/2) / cA
					oGu = (cGp*255 + cA/2) / cA
					oBu = (cBp*255 + cA/2) / cA
					oA = sA
				case internal.CompositeBlendAndDst:
					cRp = md255(md255(dA, 255-sA), dR) + md255(sA, kR)
					cGp = md255(md255(dA, 255-sA), dG) + md255(sA, kG)
					cBp = md255(md255(dA, 255-sA), dB) + md255(sA, kB)
					cA = sA + md255(dA, 255-sA)

					oRu = (cRp*255 + cA/2) / cA
					oGu = (cGp*255 + cA/2) / cA
					oBu = (cBp*255 + cA/2) / cA
					oA = dA
				case internal.CompositeBlendOnly:
					oRu, oGu, oBu = kR, kG, kB
					oA = md255(sA, dA)
				}

				oRp = md255(oRu, oA)
				oGp = md255(oGu, oA)
				oBp = md255(oBu, oA)
			}

			out[i] = uint8(oRp)
			out[i+1] = uint8(oGp)
			out[i+2] = uint8(oBp)
			out[i+3] = uint8(oA)
		}
	})
}

// BlendDifference performs a 'Difference' blend on RGBA images.
// Logic: Cr = abs(Cs - Cd)
func BlendDifference(pixIter core.PixelIterator, calc core.PixCalculator[*image.RGBA], compositing internal.BlendCompositing) *image.RGBA {
	return core.Iterate(pixIter, calc, func(dst, src, out []uint8) {
		for i := 0; i < len(src); i += 4 {
			sA := uint32(src[i+3])
			dA := uint32(dst[i+3])

			if sA == 0 {
				if compositing&internal.CompositeBlendAndDst != 0 {
					out[i], out[i+1], out[i+2], out[i+3] = dst[i], dst[i+1], dst[i+2], dst[i+3]
				} else {
					out[i], out[i+1], out[i+2], out[i+3] = 0, 0, 0, 0
				}
				continue
			}
			if dA == 0 {
				if compositing&internal.CompositeBlendAndSrc != 0 {
					out[i], out[i+1], out[i+2], out[i+3] = src[i], src[i+1], src[i+2], src[i+3]
				} else {
					out[i], out[i+1], out[i+2], out[i+3] = 0, 0, 0, 0
				}
				continue
			}

			// pre-multiplied source & destination colors
			sR, sG, sB := uint32(src[i]), uint32(src[i+1]), uint32(src[i+2])
			dR, dG, dB := uint32(dst[i]), uint32(dst[i+1]), uint32(dst[i+2])

			if (sA & dA) == 255 {
				// un-premultiplied kernel color results
				var kR, kG, kB uint32

				// region BLEND-SPECIFIC KERNEL LOGIC
				kR = min(sR-dR, dR-sR)
				kG = min(sG-dG, dG-sG)
				kB = min(sB-dB, dB-sB)
				out[i] = uint8(kR)
				out[i+1] = uint8(kG)
				out[i+2] = uint8(kB)
				// endregion BLEND-SPECIFIC KERNEL LOGIC
				out[i+3] = uint8(255)
				continue
			}

			// final output colors & alpha
			var oRp, oGp, oBp, oA uint32
			if compositing == internal.CompositeAll {
				// Fast path for Source Over using direct premultiplied equation
				oA = sA + md255(dA, 255-sA)
				// region BLEND-SPECIFIC EQUATION LOGIC
				oRp = sR + dR - div255(2*min(sR*dA, dR*sA))
				oGp = sG + dG - div255(2*min(sG*dA, dG*sA))
				oBp = sB + dB - div255(2*min(sB*dA, dB*sA))
				// endregion BLEND-SPECIFIC EQUATION LOGIC
			} else {
				// Fallback path for other compositions, or for blend modes without a direct equation.
				// This path is accurate but slower as it must un-premultiply.
				sR = unpremultiply(sR, sA)
				sG = unpremultiply(sG, sA)
				sB = unpremultiply(sB, sA)

				dR = unpremultiply(dR, dA)
				dG = unpremultiply(dG, dA)
				dB = unpremultiply(dB, dA)

				// un-premultiplied kernel color results
				var kR, kG, kB uint32

				// region BLEND-SPECIFIC KERNEL LOGIC
				kR = min(sR-dR, dR-sR)
				kG = min(sG-dG, dG-sG)
				kB = min(sB-dB, dB-sB)
				// endregion BLEND-SPECIFIC KERNEL LOGIC

				// premultiplied compositing color results
				var cRp, cGp, cBp, cA uint32

				// un-premultiplied output colors
				var oRu, oGu, oBu uint32

				switch compositing {
				case internal.CompositeBlendAndSrc:
					cRp = md255(md255(sA, 255-dA), sR) + md255(dA, kR)
					cGp = md255(md255(sA, 255-dA), sG) + md255(dA, kG)
					cBp = md255(md255(sA, 255-dA), sB) + md255(dA, kB)
					cA = dA + md255(sA, 255-dA)

					oRu = (cRp*255 + cA/2) / cA
					oGu = (cGp*255 + cA/2) / cA
					oBu = (cBp*255 + cA/2) / cA
					oA = sA
				case internal.CompositeBlendAndDst:
					cRp = md255(md255(dA, 255-sA), dR) + md255(sA, kR)
					cGp = md255(md255(dA, 255-sA), dG) + md255(sA, kG)
					cBp = md255(md255(dA, 255-sA), dB) + md255(sA, kB)
					cA = sA + md255(dA, 255-sA)

					oRu = (cRp*255 + cA/2) / cA
					oGu = (cGp*255 + cA/2) / cA
					oBu = (cBp*255 + cA/2) / cA
					oA = dA
				case internal.CompositeBlendOnly:
					oRu, oGu, oBu = kR, kG, kB
					oA = md255(sA, dA)
				}

				oRp = md255(oRu, oA)
				oGp = md255(oGu, oA)
				oBp = md255(oBu, oA)
			}

			out[i] = uint8(oRp)
			out[i+1] = uint8(oGp)
			out[i+2] = uint8(oBp)
			out[i+3] = uint8(oA)
		}
	})
}

// BlendDivide performs a 'Divide' blend on RGBA images.
// Logic: Cr = Cd / Cs
func BlendDivide(pixIter core.PixelIterator, calc core.PixCalculator[*image.RGBA], compositing internal.BlendCompositing) *image.RGBA {
	return core.Iterate(pixIter, calc, func(dst, src, out []uint8) {
		for i := 0; i < len(src); i += 4 {
			sA := uint32(src[i+3])
			dA := uint32(dst[i+3])

			if sA == 0 {
				if compositing&internal.CompositeBlendAndDst != 0 {
					out[i], out[i+1], out[i+2], out[i+3] = dst[i], dst[i+1], dst[i+2], dst[i+3]
				} else {
					out[i], out[i+1], out[i+2], out[i+3] = 0, 0, 0, 0
				}
				continue
			}
			if dA == 0 {
				if compositing&internal.CompositeBlendAndSrc != 0 {
					out[i], out[i+1], out[i+2], out[i+3] = src[i], src[i+1], src[i+2], src[i+3]
				} else {
					out[i], out[i+1], out[i+2], out[i+3] = 0, 0, 0, 0
				}
				continue
			}

			// pre-multiplied source & destination colors
			sR, sG, sB := uint32(src[i]), uint32(src[i+1]), uint32(src[i+2])
			dR, dG, dB := uint32(dst[i]), uint32(dst[i+1]), uint32(dst[i+2])

			if (sA & dA) == 255 {
				// un-premultiplied kernel color results
				var kR, kG, kB uint32

				// region BLEND-SPECIFIC KERNEL LOGIC
				if sR == 0 {
					kR = 255
				} else {
					kR = min((dR*255+sR/2)/sR, 255)
				}
				if sG == 0 {
					kG = 255
				} else {
					kG = min((dG*255+sG/2)/sG, 255)
				}
				if sB == 0 {
					kB = 255
				} else {
					kB = min((dB*255+sB/2)/sB, 255)
				}
				out[i] = uint8(kR)
				out[i+1] = uint8(kG)
				out[i+2] = uint8(kB)
				// endregion BLEND-SPECIFIC KERNEL LOGIC
				out[i+3] = uint8(255)
				continue
			}

			// final output colors & alpha
			var oRp, oGp, oBp, oA uint32
			{
				// Fallback path for other compositions, or for blend modes without a direct equation.
				// This path is accurate but slower as it must un-premultiply.
				sR = unpremultiply(sR, sA)
				sG = unpremultiply(sG, sA)
				sB = unpremultiply(sB, sA)

				dR = unpremultiply(dR, dA)
				dG = unpremultiply(dG, dA)
				dB = unpremultiply(dB, dA)

				// un-premultiplied kernel color results
				var kR, kG, kB uint32

				// region BLEND-SPECIFIC KERNEL LOGIC
				if sR == 0 {
					kR = 255
				} else {
					kR = min((dR*255+sR/2)/sR, 255)
				}
				if sG == 0 {
					kG = 255
				} else {
					kG = min((dG*255+sG/2)/sG, 255)
				}
				if sB == 0 {
					kB = 255
				} else {
					kB = min((dB*255+sB/2)/sB, 255)
				}
				// endregion BLEND-SPECIFIC KERNEL LOGIC

				// premultiplied compositing color results
				var cRp, cGp, cBp, cA uint32

				// un-premultiplied output colors
				var oRu, oGu, oBu uint32

				switch compositing {
				case internal.CompositeAll:
					invSA, invDA := 255-sA, 255-dA
					term1, term2, term3 := md255(sA, invDA), md255(dA, invSA), md255(sA, dA)

					cRp = md255(term1, sR) + md255(term2, dR) + md255(term3, kR)
					cGp = md255(term1, sG) + md255(term2, dG) + md255(term3, kG)
					cBp = md255(term1, sB) + md255(term2, dB) + md255(term3, kB)
					cA = sA + term2

					oRu = (cRp*255 + cA/2) / cA
					oGu = (cGp*255 + cA/2) / cA
					oBu = (cBp*255 + cA/2) / cA
					oA = cA
				case internal.CompositeBlendAndSrc:
					cRp = md255(md255(sA, 255-dA), sR) + md255(dA, kR)
					cGp = md255(md255(sA, 255-dA), sG) + md255(dA, kG)
					cBp = md255(md255(sA, 255-dA), sB) + md255(dA, kB)
					cA = dA + md255(sA, 255-dA)

					oRu = (cRp*255 + cA/2) / cA
					oGu = (cGp*255 + cA/2) / cA
					oBu = (cBp*255 + cA/2) / cA
					oA = sA
				case internal.CompositeBlendAndDst:
					cRp = md255(md255(dA, 255-sA), dR) + md255(sA, kR)
					cGp = md255(md255(dA, 255-sA), dG) + md255(sA, kG)
					cBp = md255(md255(dA, 255-sA), dB) + md255(sA, kB)
					cA = sA + md255(dA, 255-sA)

					oRu = (cRp*255 + cA/2) / cA
					oGu = (cGp*255 + cA/2) / cA
					oBu = (cBp*255 + cA/2) / cA
					oA = dA
				case internal.CompositeBlendOnly:
					oRu, oGu, oBu = kR, kG, kB
					oA = md255(sA, dA)
				}

				oRp = md255(oRu, oA)
				oGp = md255(oGu, oA)
				oBp = md255(oBu, oA)
			}

			out[i] = uint8(oRp)
			out[i+1] = uint8(oGp)
			out[i+2] = uint8(oBp)
			out[i+3] = uint8(oA)
		}
	})
}

// BlendExclusion performs a 'Exclusion' blend on RGBA images.
// Logic: Cr = Cs + Cd - 2 * Cs * Cd
func BlendExclusion(pixIter core.PixelIterator, calc core.PixCalculator[*image.RGBA], compositing internal.BlendCompositing) *image.RGBA {
	return core.Iterate(pixIter, calc, func(dst, src, out []uint8) {
		for i := 0; i < len(src); i += 4 {
			sA := uint32(src[i+3])
			dA := uint32(dst[i+3])

			if sA == 0 {
				if compositing&internal.CompositeBlendAndDst != 0 {
					out[i], out[i+1], out[i+2], out[i+3] = dst[i], dst[i+1], dst[i+2], dst[i+3]
				} else {
					out[i], out[i+1], out[i+2], out[i+3] = 0, 0, 0, 0
				}
				continue
			}
			if dA == 0 {
				if compositing&internal.CompositeBlendAndSrc != 0 {
					out[i], out[i+1], out[i+2], out[i+3] = src[i], src[i+1], src[i+2], src[i+3]
				} else {
					out[i], out[i+1], out[i+2], out[i+3] = 0, 0, 0, 0
				}
				continue
			}

			// pre-multiplied source & destination colors
			sR, sG, sB := uint32(src[i]), uint32(src[i+1]), uint32(src[i+2])
			dR, dG, dB := uint32(dst[i]), uint32(dst[i+1]), uint32(dst[i+2])

			if (sA & dA) == 255 {
				// un-premultiplied kernel color results
				var kR, kG, kB uint32

				// region BLEND-SPECIFIC KERNEL LOGIC
				kR = sR + dR - 2*md255(sR, dR)
				kG = sG + dG - 2*md255(sG, dG)
				kB = sB + dB - 2*md255(sB, dB)
				out[i] = uint8(kR)
				out[i+1] = uint8(kG)
				out[i+2] = uint8(kB)
				// endregion BLEND-SPECIFIC KERNEL LOGIC
				out[i+3] = uint8(255)
				continue
			}

			// final output colors & alpha
			var oRp, oGp, oBp, oA uint32
			if compositing == internal.CompositeAll {
				// Fast path for Source Over using direct premultiplied equation
				oA = sA + md255(dA, 255-sA)
				// region BLEND-SPECIFIC EQUATION LOGIC
				oRp = sR + dR - 2*md255(sR, dR)
				oGp = sG + dG - 2*md255(sG, dG)
				oBp = sB + dB - 2*md255(sB, dB)
				// endregion BLEND-SPECIFIC EQUATION LOGIC
			} else {
				// Fallback path for other compositions, or for blend modes without a direct equation.
				// This path is accurate but slower as it must un-premultiply.
				sR = unpremultiply(sR, sA)
				sG = unpremultiply(sG, sA)
				sB = unpremultiply(sB, sA)

				dR = unpremultiply(dR, dA)
				dG = unpremultiply(dG, dA)
				dB = unpremultiply(dB, dA)

				// un-premultiplied kernel color results
				var kR, kG, kB uint32

				// region BLEND-SPECIFIC KERNEL LOGIC
				kR = sR + dR - 2*md255(sR, dR)
				kG = sG + dG - 2*md255(sG, dG)
				kB = sB + dB - 2*md255(sB, dB)
				// endregion BLEND-SPECIFIC KERNEL LOGIC

				// premultiplied compositing color results
				var cRp, cGp, cBp, cA uint32

				// un-premultiplied output colors
				var oRu, oGu, oBu uint32

				switch compositing {
				case internal.CompositeBlendAndSrc:
					cRp = md255(md255(sA, 255-dA), sR) + md255(dA, kR)
					cGp = md255(md255(sA, 255-dA), sG) + md255(dA, kG)
					cBp = md255(md255(sA, 255-dA), sB) + md255(dA, kB)
					cA = dA + md255(sA, 255-dA)

					oRu = (cRp*255 + cA/2) / cA
					oGu = (cGp*255 + cA/2) / cA
					oBu = (cBp*255 + cA/2) / cA
					oA = sA
				case internal.CompositeBlendAndDst:
					cRp = md255(md255(dA, 255-sA), dR) + md255(sA, kR)
					cGp = md255(md255(dA, 255-sA), dG) + md255(sA, kG)
					cBp = md255(md255(dA, 255-sA), dB) + md255(sA, kB)
					cA = sA + md255(dA, 255-sA)

					oRu = (cRp*255 + cA/2) / cA
					oGu = (cGp*255 + cA/2) / cA
					oBu = (cBp*255 + cA/2) / cA
					oA = dA
				case internal.CompositeBlendOnly:
					oRu, oGu, oBu = kR, kG, kB
					oA = md255(sA, dA)
				}

				oRp = md255(oRu, oA)
				oGp = md255(oGu, oA)
				oBp = md255(oBu, oA)
			}

			out[i] = uint8(oRp)
			out[i+1] = uint8(oGp)
			out[i+2] = uint8(oBp)
			out[i+3] = uint8(oA)
		}
	})
}

// BlendHardLight performs a 'HardLight' blend on RGBA images.
// Logic: if Cs < 0.5 { Cr = 2 * Cs * Cd } else { Cr = 1 - 2 * (1 - Cs) * (1 - Cd) }
func BlendHardLight(pixIter core.PixelIterator, calc core.PixCalculator[*image.RGBA], compositing internal.BlendCompositing) *image.RGBA {
	return core.Iterate(pixIter, calc, func(dst, src, out []uint8) {
		for i := 0; i < len(src); i += 4 {
			sA := uint32(src[i+3])
			dA := uint32(dst[i+3])

			if sA == 0 {
				if compositing&internal.CompositeBlendAndDst != 0 {
					out[i], out[i+1], out[i+2], out[i+3] = dst[i], dst[i+1], dst[i+2], dst[i+3]
				} else {
					out[i], out[i+1], out[i+2], out[i+3] = 0, 0, 0, 0
				}
				continue
			}
			if dA == 0 {
				if compositing&internal.CompositeBlendAndSrc != 0 {
					out[i], out[i+1], out[i+2], out[i+3] = src[i], src[i+1], src[i+2], src[i+3]
				} else {
					out[i], out[i+1], out[i+2], out[i+3] = 0, 0, 0, 0
				}
				continue
			}

			// pre-multiplied source & destination colors
			sR, sG, sB := uint32(src[i]), uint32(src[i+1]), uint32(src[i+2])
			dR, dG, dB := uint32(dst[i]), uint32(dst[i+1]), uint32(dst[i+2])

			if (sA & dA) == 255 {
				// un-premultiplied kernel color results
				var kR, kG, kB uint32

				// region BLEND-SPECIFIC KERNEL LOGIC
				if sR < 128 {
					kR = 2 * md255(sR, dR)
				} else {
					kR = 255 - 2*md255(255-sR, 255-dR)
				}
				if sG < 128 {
					kG = 2 * md255(sG, dG)
				} else {
					kG = 255 - 2*md255(255-sG, 255-dG)
				}
				if sB < 128 {
					kB = 2 * md255(sB, dB)
				} else {
					kB = 255 - 2*md255(255-sB, 255-dB)
				}
				out[i] = uint8(kR)
				out[i+1] = uint8(kG)
				out[i+2] = uint8(kB)
				// endregion BLEND-SPECIFIC KERNEL LOGIC
				out[i+3] = uint8(255)
				continue
			}

			// final output colors & alpha
			var oRp, oGp, oBp, oA uint32
			{
				// Fallback path for other compositions, or for blend modes without a direct equation.
				// This path is accurate but slower as it must un-premultiply.
				sR = unpremultiply(sR, sA)
				sG = unpremultiply(sG, sA)
				sB = unpremultiply(sB, sA)

				dR = unpremultiply(dR, dA)
				dG = unpremultiply(dG, dA)
				dB = unpremultiply(dB, dA)

				// un-premultiplied kernel color results
				var kR, kG, kB uint32

				// region BLEND-SPECIFIC KERNEL LOGIC
				if sR < 128 {
					kR = 2 * md255(sR, dR)
				} else {
					kR = 255 - 2*md255(255-sR, 255-dR)
				}
				if sG < 128 {
					kG = 2 * md255(sG, dG)
				} else {
					kG = 255 - 2*md255(255-sG, 255-dG)
				}
				if sB < 128 {
					kB = 2 * md255(sB, dB)
				} else {
					kB = 255 - 2*md255(255-sB, 255-dB)
				}
				// endregion BLEND-SPECIFIC KERNEL LOGIC

				// premultiplied compositing color results
				var cRp, cGp, cBp, cA uint32

				// un-premultiplied output colors
				var oRu, oGu, oBu uint32

				switch compositing {
				case internal.CompositeAll:
					invSA, invDA := 255-sA, 255-dA
					term1, term2, term3 := md255(sA, invDA), md255(dA, invSA), md255(sA, dA)

					cRp = md255(term1, sR) + md255(term2, dR) + md255(term3, kR)
					cGp = md255(term1, sG) + md255(term2, dG) + md255(term3, kG)
					cBp = md255(term1, sB) + md255(term2, dB) + md255(term3, kB)
					cA = sA + term2

					oRu = (cRp*255 + cA/2) / cA
					oGu = (cGp*255 + cA/2) / cA
					oBu = (cBp*255 + cA/2) / cA
					oA = cA
				case internal.CompositeBlendAndSrc:
					cRp = md255(md255(sA, 255-dA), sR) + md255(dA, kR)
					cGp = md255(md255(sA, 255-dA), sG) + md255(dA, kG)
					cBp = md255(md255(sA, 255-dA), sB) + md255(dA, kB)
					cA = dA + md255(sA, 255-dA)

					oRu = (cRp*255 + cA/2) / cA
					oGu = (cGp*255 + cA/2) / cA
					oBu = (cBp*255 + cA/2) / cA
					oA = sA
				case internal.CompositeBlendAndDst:
					cRp = md255(md255(dA, 255-sA), dR) + md255(sA, kR)
					cGp = md255(md255(dA, 255-sA), dG) + md255(sA, kG)
					cBp = md255(md255(dA, 255-sA), dB) + md255(sA, kB)
					cA = sA + md255(dA, 255-sA)

					oRu = (cRp*255 + cA/2) / cA
					oGu = (cGp*255 + cA/2) / cA
					oBu = (cBp*255 + cA/2) / cA
					oA = dA
				case internal.CompositeBlendOnly:
					oRu, oGu, oBu = kR, kG, kB
					oA = md255(sA, dA)
				}

				oRp = md255(oRu, oA)
				oGp = md255(oGu, oA)
				oBp = md255(oBu, oA)
			}

			out[i] = uint8(oRp)
			out[i+1] = uint8(oGp)
			out[i+2] = uint8(oBp)
			out[i+3] = uint8(oA)
		}
	})
}

// BlendHardMix performs a 'HardMix' blend on RGBA images.
// Logic: if Cs + Cd < 1 { Cr = 0 } else { Cr = 1 }
func BlendHardMix(pixIter core.PixelIterator, calc core.PixCalculator[*image.RGBA], compositing internal.BlendCompositing) *image.RGBA {
	return core.Iterate(pixIter, calc, func(dst, src, out []uint8) {
		for i := 0; i < len(src); i += 4 {
			sA := uint32(src[i+3])
			dA := uint32(dst[i+3])

			if sA == 0 {
				if compositing&internal.CompositeBlendAndDst != 0 {
					out[i], out[i+1], out[i+2], out[i+3] = dst[i], dst[i+1], dst[i+2], dst[i+3]
				} else {
					out[i], out[i+1], out[i+2], out[i+3] = 0, 0, 0, 0
				}
				continue
			}
			if dA == 0 {
				if compositing&internal.CompositeBlendAndSrc != 0 {
					out[i], out[i+1], out[i+2], out[i+3] = src[i], src[i+1], src[i+2], src[i+3]
				} else {
					out[i], out[i+1], out[i+2], out[i+3] = 0, 0, 0, 0
				}
				continue
			}

			// pre-multiplied source & destination colors
			sR, sG, sB := uint32(src[i]), uint32(src[i+1]), uint32(src[i+2])
			dR, dG, dB := uint32(dst[i]), uint32(dst[i+1]), uint32(dst[i+2])

			if (sA & dA) == 255 {
				// un-premultiplied kernel color results
				var kR, kG, kB uint32

				// region BLEND-SPECIFIC KERNEL LOGIC
				if sR+dR < 255 {
					kR = 0
				} else {
					kR = 255
				}
				if sG+dG < 255 {
					kG = 0
				} else {
					kG = 255
				}
				if sB+dB < 255 {
					kB = 0
				} else {
					kB = 255
				}
				out[i] = uint8(kR)
				out[i+1] = uint8(kG)
				out[i+2] = uint8(kB)
				// endregion BLEND-SPECIFIC KERNEL LOGIC
				out[i+3] = uint8(255)
				continue
			}

			// final output colors & alpha
			var oRp, oGp, oBp, oA uint32
			{
				// Fallback path for other compositions, or for blend modes without a direct equation.
				// This path is accurate but slower as it must un-premultiply.
				sR = unpremultiply(sR, sA)
				sG = unpremultiply(sG, sA)
				sB = unpremultiply(sB, sA)

				dR = unpremultiply(dR, dA)
				dG = unpremultiply(dG, dA)
				dB = unpremultiply(dB, dA)

				// un-premultiplied kernel color results
				var kR, kG, kB uint32

				// region BLEND-SPECIFIC KERNEL LOGIC
				if sR+dR < 255 {
					kR = 0
				} else {
					kR = 255
				}
				if sG+dG < 255 {
					kG = 0
				} else {
					kG = 255
				}
				if sB+dB < 255 {
					kB = 0
				} else {
					kB = 255
				}
				// endregion BLEND-SPECIFIC KERNEL LOGIC

				// premultiplied compositing color results
				var cRp, cGp, cBp, cA uint32

				// un-premultiplied output colors
				var oRu, oGu, oBu uint32

				switch compositing {
				case internal.CompositeAll:
					invSA, invDA := 255-sA, 255-dA
					term1, term2, term3 := md255(sA, invDA), md255(dA, invSA), md255(sA, dA)

					cRp = md255(term1, sR) + md255(term2, dR) + md255(term3, kR)
					cGp = md255(term1, sG) + md255(term2, dG) + md255(term3, kG)
					cBp = md255(term1, sB) + md255(term2, dB) + md255(term3, kB)
					cA = sA + term2

					oRu = (cRp*255 + cA/2) / cA
					oGu = (cGp*255 + cA/2) / cA
					oBu = (cBp*255 + cA/2) / cA
					oA = cA
				case internal.CompositeBlendAndSrc:
					cRp = md255(md255(sA, 255-dA), sR) + md255(dA, kR)
					cGp = md255(md255(sA, 255-dA), sG) + md255(dA, kG)
					cBp = md255(md255(sA, 255-dA), sB) + md255(dA, kB)
					cA = dA + md255(sA, 255-dA)

					oRu = (cRp*255 + cA/2) / cA
					oGu = (cGp*255 + cA/2) / cA
					oBu = (cBp*255 + cA/2) / cA
					oA = sA
				case internal.CompositeBlendAndDst:
					cRp = md255(md255(dA, 255-sA), dR) + md255(sA, kR)
					cGp = md255(md255(dA, 255-sA), dG) + md255(sA, kG)
					cBp = md255(md255(dA, 255-sA), dB) + md255(sA, kB)
					cA = sA + md255(dA, 255-sA)

					oRu = (cRp*255 + cA/2) / cA
					oGu = (cGp*255 + cA/2) / cA
					oBu = (cBp*255 + cA/2) / cA
					oA = dA
				case internal.CompositeBlendOnly:
					oRu, oGu, oBu = kR, kG, kB
					oA = md255(sA, dA)
				}

				oRp = md255(oRu, oA)
				oGp = md255(oGu, oA)
				oBp = md255(oBu, oA)
			}

			out[i] = uint8(oRp)
			out[i+1] = uint8(oGp)
			out[i+2] = uint8(oBp)
			out[i+3] = uint8(oA)
		}
	})
}

// BlendLighten performs a 'Lighten' blend on RGBA images.
// Logic: Cr = max(Cs, Cd)
func BlendLighten(pixIter core.PixelIterator, calc core.PixCalculator[*image.RGBA], compositing internal.BlendCompositing) *image.RGBA {
	return core.Iterate(pixIter, calc, func(dst, src, out []uint8) {
		for i := 0; i < len(src); i += 4 {
			sA := uint32(src[i+3])
			dA := uint32(dst[i+3])

			if sA == 0 {
				if compositing&internal.CompositeBlendAndDst != 0 {
					out[i], out[i+1], out[i+2], out[i+3] = dst[i], dst[i+1], dst[i+2], dst[i+3]
				} else {
					out[i], out[i+1], out[i+2], out[i+3] = 0, 0, 0, 0
				}
				continue
			}
			if dA == 0 {
				if compositing&internal.CompositeBlendAndSrc != 0 {
					out[i], out[i+1], out[i+2], out[i+3] = src[i], src[i+1], src[i+2], src[i+3]
				} else {
					out[i], out[i+1], out[i+2], out[i+3] = 0, 0, 0, 0
				}
				continue
			}

			// pre-multiplied source & destination colors
			sR, sG, sB := uint32(src[i]), uint32(src[i+1]), uint32(src[i+2])
			dR, dG, dB := uint32(dst[i]), uint32(dst[i+1]), uint32(dst[i+2])

			if (sA & dA) == 255 {
				// un-premultiplied kernel color results
				var kR, kG, kB uint32

				// region BLEND-SPECIFIC KERNEL LOGIC
				kR = max(sR, dR)
				kG = max(sG, dG)
				kB = max(sB, dB)
				out[i] = uint8(kR)
				out[i+1] = uint8(kG)
				out[i+2] = uint8(kB)
				// endregion BLEND-SPECIFIC KERNEL LOGIC
				out[i+3] = uint8(255)
				continue
			}

			// final output colors & alpha
			var oRp, oGp, oBp, oA uint32
			{
				// Fallback path for other compositions, or for blend modes without a direct equation.
				// This path is accurate but slower as it must un-premultiply.
				sR = unpremultiply(sR, sA)
				sG = unpremultiply(sG, sA)
				sB = unpremultiply(sB, sA)

				dR = unpremultiply(dR, dA)
				dG = unpremultiply(dG, dA)
				dB = unpremultiply(dB, dA)

				// un-premultiplied kernel color results
				var kR, kG, kB uint32

				// region BLEND-SPECIFIC KERNEL LOGIC
				kR = max(sR, dR)
				kG = max(sG, dG)
				kB = max(sB, dB)
				// endregion BLEND-SPECIFIC KERNEL LOGIC

				// premultiplied compositing color results
				var cRp, cGp, cBp, cA uint32

				// un-premultiplied output colors
				var oRu, oGu, oBu uint32

				switch compositing {
				case internal.CompositeAll:
					invSA, invDA := 255-sA, 255-dA
					term1, term2, term3 := md255(sA, invDA), md255(dA, invSA), md255(sA, dA)

					cRp = md255(term1, sR) + md255(term2, dR) + md255(term3, kR)
					cGp = md255(term1, sG) + md255(term2, dG) + md255(term3, kG)
					cBp = md255(term1, sB) + md255(term2, dB) + md255(term3, kB)
					cA = sA + term2

					oRu = (cRp*255 + cA/2) / cA
					oGu = (cGp*255 + cA/2) / cA
					oBu = (cBp*255 + cA/2) / cA
					oA = cA
				case internal.CompositeBlendAndSrc:
					cRp = md255(md255(sA, 255-dA), sR) + md255(dA, kR)
					cGp = md255(md255(sA, 255-dA), sG) + md255(dA, kG)
					cBp = md255(md255(sA, 255-dA), sB) + md255(dA, kB)
					cA = dA + md255(sA, 255-dA)

					oRu = (cRp*255 + cA/2) / cA
					oGu = (cGp*255 + cA/2) / cA
					oBu = (cBp*255 + cA/2) / cA
					oA = sA
				case internal.CompositeBlendAndDst:
					cRp = md255(md255(dA, 255-sA), dR) + md255(sA, kR)
					cGp = md255(md255(dA, 255-sA), dG) + md255(sA, kG)
					cBp = md255(md255(dA, 255-sA), dB) + md255(sA, kB)
					cA = sA + md255(dA, 255-sA)

					oRu = (cRp*255 + cA/2) / cA
					oGu = (cGp*255 + cA/2) / cA
					oBu = (cBp*255 + cA/2) / cA
					oA = dA
				case internal.CompositeBlendOnly:
					oRu, oGu, oBu = kR, kG, kB
					oA = md255(sA, dA)
				}

				oRp = md255(oRu, oA)
				oGp = md255(oGu, oA)
				oBp = md255(oBu, oA)
			}

			out[i] = uint8(oRp)
			out[i+1] = uint8(oGp)
			out[i+2] = uint8(oBp)
			out[i+3] = uint8(oA)
		}
	})
}

// BlendLinearBurn performs a 'LinearBurn' blend on RGBA images.
// Logic: Cr = Cs + Cd - 1
func BlendLinearBurn(pixIter core.PixelIterator, calc core.PixCalculator[*image.RGBA], compositing internal.BlendCompositing) *image.RGBA {
	return core.Iterate(pixIter, calc, func(dst, src, out []uint8) {
		for i := 0; i < len(src); i += 4 {
			sA := uint32(src[i+3])
			dA := uint32(dst[i+3])

			if sA == 0 {
				if compositing&internal.CompositeBlendAndDst != 0 {
					out[i], out[i+1], out[i+2], out[i+3] = dst[i], dst[i+1], dst[i+2], dst[i+3]
				} else {
					out[i], out[i+1], out[i+2], out[i+3] = 0, 0, 0, 0
				}
				continue
			}
			if dA == 0 {
				if compositing&internal.CompositeBlendAndSrc != 0 {
					out[i], out[i+1], out[i+2], out[i+3] = src[i], src[i+1], src[i+2], src[i+3]
				} else {
					out[i], out[i+1], out[i+2], out[i+3] = 0, 0, 0, 0
				}
				continue
			}

			// pre-multiplied source & destination colors
			sR, sG, sB := uint32(src[i]), uint32(src[i+1]), uint32(src[i+2])
			dR, dG, dB := uint32(dst[i]), uint32(dst[i+1]), uint32(dst[i+2])

			if (sA & dA) == 255 {
				// un-premultiplied kernel color results
				var kR, kG, kB uint32

				// region BLEND-SPECIFIC KERNEL LOGIC
				kR = sR + dR - 255
				if kR > 255 {
					kR = 0
				}
				kG = sG + dG - 255
				if kG > 255 {
					kG = 0
				}
				kB = sB + dB - 255
				if kB > 255 {
					kB = 0
				}
				out[i] = uint8(kR)
				out[i+1] = uint8(kG)
				out[i+2] = uint8(kB)
				// endregion BLEND-SPECIFIC KERNEL LOGIC
				out[i+3] = uint8(255)
				continue
			}

			// final output colors & alpha
			var oRp, oGp, oBp, oA uint32
			{
				// Fallback path for other compositions, or for blend modes without a direct equation.
				// This path is accurate but slower as it must un-premultiply.
				sR = unpremultiply(sR, sA)
				sG = unpremultiply(sG, sA)
				sB = unpremultiply(sB, sA)

				dR = unpremultiply(dR, dA)
				dG = unpremultiply(dG, dA)
				dB = unpremultiply(dB, dA)

				// un-premultiplied kernel color results
				var kR, kG, kB uint32

				// region BLEND-SPECIFIC KERNEL LOGIC
				kR = sR + dR - 255
				if kR > 255 {
					kR = 0
				}
				kG = sG + dG - 255
				if kG > 255 {
					kG = 0
				}
				kB = sB + dB - 255
				if kB > 255 {
					kB = 0
				}
				// endregion BLEND-SPECIFIC KERNEL LOGIC

				// premultiplied compositing color results
				var cRp, cGp, cBp, cA uint32

				// un-premultiplied output colors
				var oRu, oGu, oBu uint32

				switch compositing {
				case internal.CompositeAll:
					invSA, invDA := 255-sA, 255-dA
					term1, term2, term3 := md255(sA, invDA), md255(dA, invSA), md255(sA, dA)

					cRp = md255(term1, sR) + md255(term2, dR) + md255(term3, kR)
					cGp = md255(term1, sG) + md255(term2, dG) + md255(term3, kG)
					cBp = md255(term1, sB) + md255(term2, dB) + md255(term3, kB)
					cA = sA + term2

					oRu = (cRp*255 + cA/2) / cA
					oGu = (cGp*255 + cA/2) / cA
					oBu = (cBp*255 + cA/2) / cA
					oA = cA
				case internal.CompositeBlendAndSrc:
					cRp = md255(md255(sA, 255-dA), sR) + md255(dA, kR)
					cGp = md255(md255(sA, 255-dA), sG) + md255(dA, kG)
					cBp = md255(md255(sA, 255-dA), sB) + md255(dA, kB)
					cA = dA + md255(sA, 255-dA)

					oRu = (cRp*255 + cA/2) / cA
					oGu = (cGp*255 + cA/2) / cA
					oBu = (cBp*255 + cA/2) / cA
					oA = sA
				case internal.CompositeBlendAndDst:
					cRp = md255(md255(dA, 255-sA), dR) + md255(sA, kR)
					cGp = md255(md255(dA, 255-sA), dG) + md255(sA, kG)
					cBp = md255(md255(dA, 255-sA), dB) + md255(sA, kB)
					cA = sA + md255(dA, 255-sA)

					oRu = (cRp*255 + cA/2) / cA
					oGu = (cGp*255 + cA/2) / cA
					oBu = (cBp*255 + cA/2) / cA
					oA = dA
				case internal.CompositeBlendOnly:
					oRu, oGu, oBu = kR, kG, kB
					oA = md255(sA, dA)
				}

				oRp = md255(oRu, oA)
				oGp = md255(oGu, oA)
				oBp = md255(oBu, oA)
			}

			out[i] = uint8(oRp)
			out[i+1] = uint8(oGp)
			out[i+2] = uint8(oBp)
			out[i+3] = uint8(oA)
		}
	})
}

// BlendLinearDodge performs a 'LinearDodge' blend on RGBA images.
// Logic: Cr = Cs + Cd
func BlendLinearDodge(pixIter core.PixelIterator, calc core.PixCalculator[*image.RGBA], compositing internal.BlendCompositing) *image.RGBA {
	return core.Iterate(pixIter, calc, func(dst, src, out []uint8) {
		for i := 0; i < len(src); i += 4 {
			sA := uint32(src[i+3])
			dA := uint32(dst[i+3])

			if sA == 0 {
				if compositing&internal.CompositeBlendAndDst != 0 {
					out[i], out[i+1], out[i+2], out[i+3] = dst[i], dst[i+1], dst[i+2], dst[i+3]
				} else {
					out[i], out[i+1], out[i+2], out[i+3] = 0, 0, 0, 0
				}
				continue
			}
			if dA == 0 {
				if compositing&internal.CompositeBlendAndSrc != 0 {
					out[i], out[i+1], out[i+2], out[i+3] = src[i], src[i+1], src[i+2], src[i+3]
				} else {
					out[i], out[i+1], out[i+2], out[i+3] = 0, 0, 0, 0
				}
				continue
			}

			// pre-multiplied source & destination colors
			sR, sG, sB := uint32(src[i]), uint32(src[i+1]), uint32(src[i+2])
			dR, dG, dB := uint32(dst[i]), uint32(dst[i+1]), uint32(dst[i+2])

			if (sA & dA) == 255 {
				// un-premultiplied kernel color results
				var kR, kG, kB uint32

				// region BLEND-SPECIFIC KERNEL LOGIC
				kR = min(sR+dR, 255)
				kG = min(sG+dG, 255)
				kB = min(sB+dB, 255)
				out[i] = uint8(kR)
				out[i+1] = uint8(kG)
				out[i+2] = uint8(kB)
				// endregion BLEND-SPECIFIC KERNEL LOGIC
				out[i+3] = uint8(255)
				continue
			}

			// final output colors & alpha
			var oRp, oGp, oBp, oA uint32
			{
				// Fallback path for other compositions, or for blend modes without a direct equation.
				// This path is accurate but slower as it must un-premultiply.
				sR = unpremultiply(sR, sA)
				sG = unpremultiply(sG, sA)
				sB = unpremultiply(sB, sA)

				dR = unpremultiply(dR, dA)
				dG = unpremultiply(dG, dA)
				dB = unpremultiply(dB, dA)

				// un-premultiplied kernel color results
				var kR, kG, kB uint32

				// region BLEND-SPECIFIC KERNEL LOGIC
				kR = min(sR+dR, 255)
				kG = min(sG+dG, 255)
				kB = min(sB+dB, 255)
				// endregion BLEND-SPECIFIC KERNEL LOGIC

				// premultiplied compositing color results
				var cRp, cGp, cBp, cA uint32

				// un-premultiplied output colors
				var oRu, oGu, oBu uint32

				switch compositing {
				case internal.CompositeAll:
					invSA, invDA := 255-sA, 255-dA
					term1, term2, term3 := md255(sA, invDA), md255(dA, invSA), md255(sA, dA)

					cRp = md255(term1, sR) + md255(term2, dR) + md255(term3, kR)
					cGp = md255(term1, sG) + md255(term2, dG) + md255(term3, kG)
					cBp = md255(term1, sB) + md255(term2, dB) + md255(term3, kB)
					cA = sA + term2

					oRu = (cRp*255 + cA/2) / cA
					oGu = (cGp*255 + cA/2) / cA
					oBu = (cBp*255 + cA/2) / cA
					oA = cA
				case internal.CompositeBlendAndSrc:
					cRp = md255(md255(sA, 255-dA), sR) + md255(dA, kR)
					cGp = md255(md255(sA, 255-dA), sG) + md255(dA, kG)
					cBp = md255(md255(sA, 255-dA), sB) + md255(dA, kB)
					cA = dA + md255(sA, 255-dA)

					oRu = (cRp*255 + cA/2) / cA
					oGu = (cGp*255 + cA/2) / cA
					oBu = (cBp*255 + cA/2) / cA
					oA = sA
				case internal.CompositeBlendAndDst:
					cRp = md255(md255(dA, 255-sA), dR) + md255(sA, kR)
					cGp = md255(md255(dA, 255-sA), dG) + md255(sA, kG)
					cBp = md255(md255(dA, 255-sA), dB) + md255(sA, kB)
					cA = sA + md255(dA, 255-sA)

					oRu = (cRp*255 + cA/2) / cA
					oGu = (cGp*255 + cA/2) / cA
					oBu = (cBp*255 + cA/2) / cA
					oA = dA
				case internal.CompositeBlendOnly:
					oRu, oGu, oBu = kR, kG, kB
					oA = md255(sA, dA)
				}

				oRp = md255(oRu, oA)
				oGp = md255(oGu, oA)
				oBp = md255(oBu, oA)
			}

			out[i] = uint8(oRp)
			out[i+1] = uint8(oGp)
			out[i+2] = uint8(oBp)
			out[i+3] = uint8(oA)
		}
	})
}

// BlendLinearLight performs a 'LinearLight' blend on RGBA images.
// Logic: Cr = Cd + 2*Cs - 1
func BlendLinearLight(pixIter core.PixelIterator, calc core.PixCalculator[*image.RGBA], compositing internal.BlendCompositing) *image.RGBA {
	return core.Iterate(pixIter, calc, func(dst, src, out []uint8) {
		for i := 0; i < len(src); i += 4 {
			sA := uint32(src[i+3])
			dA := uint32(dst[i+3])

			if sA == 0 {
				if compositing&internal.CompositeBlendAndDst != 0 {
					out[i], out[i+1], out[i+2], out[i+3] = dst[i], dst[i+1], dst[i+2], dst[i+3]
				} else {
					out[i], out[i+1], out[i+2], out[i+3] = 0, 0, 0, 0
				}
				continue
			}
			if dA == 0 {
				if compositing&internal.CompositeBlendAndSrc != 0 {
					out[i], out[i+1], out[i+2], out[i+3] = src[i], src[i+1], src[i+2], src[i+3]
				} else {
					out[i], out[i+1], out[i+2], out[i+3] = 0, 0, 0, 0
				}
				continue
			}

			// pre-multiplied source & destination colors
			sR, sG, sB := uint32(src[i]), uint32(src[i+1]), uint32(src[i+2])
			dR, dG, dB := uint32(dst[i]), uint32(dst[i+1]), uint32(dst[i+2])

			if (sA & dA) == 255 {
				// un-premultiplied kernel color results
				var kR, kG, kB uint32

				// region BLEND-SPECIFIC KERNEL LOGIC
				kR = dR + 2*sR - 255
				if kR > 510 {
					kR = 0
				} else if kR > 255 {
					kR = 255
				}
				kG = dG + 2*sG - 255
				if kG > 510 {
					kG = 0
				} else if kG > 255 {
					kG = 255
				}
				kB = dB + 2*sB - 255
				if kB > 510 {
					kB = 0
				} else if kB > 255 {
					kB = 255
				}
				out[i] = uint8(kR)
				out[i+1] = uint8(kG)
				out[i+2] = uint8(kB)
				// endregion BLEND-SPECIFIC KERNEL LOGIC
				out[i+3] = uint8(255)
				continue
			}

			// final output colors & alpha
			var oRp, oGp, oBp, oA uint32
			{
				// Fallback path for other compositions, or for blend modes without a direct equation.
				// This path is accurate but slower as it must un-premultiply.
				sR = unpremultiply(sR, sA)
				sG = unpremultiply(sG, sA)
				sB = unpremultiply(sB, sA)

				dR = unpremultiply(dR, dA)
				dG = unpremultiply(dG, dA)
				dB = unpremultiply(dB, dA)

				// un-premultiplied kernel color results
				var kR, kG, kB uint32

				// region BLEND-SPECIFIC KERNEL LOGIC
				kR = dR + 2*sR - 255
				if kR > 510 {
					kR = 0
				} else if kR > 255 {
					kR = 255
				}
				kG = dG + 2*sG - 255
				if kG > 510 {
					kG = 0
				} else if kG > 255 {
					kG = 255
				}
				kB = dB + 2*sB - 255
				if kB > 510 {
					kB = 0
				} else if kB > 255 {
					kB = 255
				}
				// endregion BLEND-SPECIFIC KERNEL LOGIC

				// premultiplied compositing color results
				var cRp, cGp, cBp, cA uint32

				// un-premultiplied output colors
				var oRu, oGu, oBu uint32

				switch compositing {
				case internal.CompositeAll:
					invSA, invDA := 255-sA, 255-dA
					term1, term2, term3 := md255(sA, invDA), md255(dA, invSA), md255(sA, dA)

					cRp = md255(term1, sR) + md255(term2, dR) + md255(term3, kR)
					cGp = md255(term1, sG) + md255(term2, dG) + md255(term3, kG)
					cBp = md255(term1, sB) + md255(term2, dB) + md255(term3, kB)
					cA = sA + term2

					oRu = (cRp*255 + cA/2) / cA
					oGu = (cGp*255 + cA/2) / cA
					oBu = (cBp*255 + cA/2) / cA
					oA = cA
				case internal.CompositeBlendAndSrc:
					cRp = md255(md255(sA, 255-dA), sR) + md255(dA, kR)
					cGp = md255(md255(sA, 255-dA), sG) + md255(dA, kG)
					cBp = md255(md255(sA, 255-dA), sB) + md255(dA, kB)
					cA = dA + md255(sA, 255-dA)

					oRu = (cRp*255 + cA/2) / cA
					oGu = (cGp*255 + cA/2) / cA
					oBu = (cBp*255 + cA/2) / cA
					oA = sA
				case internal.CompositeBlendAndDst:
					cRp = md255(md255(dA, 255-sA), dR) + md255(sA, kR)
					cGp = md255(md255(dA, 255-sA), dG) + md255(sA, kG)
					cBp = md255(md255(dA, 255-sA), dB) + md255(sA, kB)
					cA = sA + md255(dA, 255-sA)

					oRu = (cRp*255 + cA/2) / cA
					oGu = (cGp*255 + cA/2) / cA
					oBu = (cBp*255 + cA/2) / cA
					oA = dA
				case internal.CompositeBlendOnly:
					oRu, oGu, oBu = kR, kG, kB
					oA = md255(sA, dA)
				}

				oRp = md255(oRu, oA)
				oGp = md255(oGu, oA)
				oBp = md255(oBu, oA)
			}

			out[i] = uint8(oRp)
			out[i+1] = uint8(oGp)
			out[i+2] = uint8(oBp)
			out[i+3] = uint8(oA)
		}
	})
}

// BlendMultiply performs a 'Multiply' blend on RGBA images.
// Logic: Cr = Cs * Cd
func BlendMultiply(pixIter core.PixelIterator, calc core.PixCalculator[*image.RGBA], compositing internal.BlendCompositing) *image.RGBA {
	return core.Iterate(pixIter, calc, func(dst, src, out []uint8) {
		for i := 0; i < len(src); i += 4 {
			sA := uint32(src[i+3])
			dA := uint32(dst[i+3])

			if sA == 0 {
				if compositing&internal.CompositeBlendAndDst != 0 {
					out[i], out[i+1], out[i+2], out[i+3] = dst[i], dst[i+1], dst[i+2], dst[i+3]
				} else {
					out[i], out[i+1], out[i+2], out[i+3] = 0, 0, 0, 0
				}
				continue
			}
			if dA == 0 {
				if compositing&internal.CompositeBlendAndSrc != 0 {
					out[i], out[i+1], out[i+2], out[i+3] = src[i], src[i+1], src[i+2], src[i+3]
				} else {
					out[i], out[i+1], out[i+2], out[i+3] = 0, 0, 0, 0
				}
				continue
			}

			// pre-multiplied source & destination colors
			sR, sG, sB := uint32(src[i]), uint32(src[i+1]), uint32(src[i+2])
			dR, dG, dB := uint32(dst[i]), uint32(dst[i+1]), uint32(dst[i+2])

			if (sA & dA) == 255 {
				// un-premultiplied kernel color results
				var kR, kG, kB uint32

				// region BLEND-SPECIFIC KERNEL LOGIC
				kR = md255(sR, dR)
				kG = md255(sG, dG)
				kB = md255(sB, dB)
				out[i] = uint8(kR)
				out[i+1] = uint8(kG)
				out[i+2] = uint8(kB)
				// endregion BLEND-SPECIFIC KERNEL LOGIC
				out[i+3] = uint8(255)
				continue
			}

			// final output colors & alpha
			var oRp, oGp, oBp, oA uint32
			if compositing == internal.CompositeAll {
				// Fast path for Source Over using direct premultiplied equation
				oA = sA + md255(dA, 255-sA)
				// region BLEND-SPECIFIC EQUATION LOGIC
				oRp = md255(dR, 255-sA) + md255(sR, 255-dA) + md255(sR, dR)
				oGp = md255(dG, 255-sA) + md255(sG, 255-dA) + md255(sG, dG)
				oBp = md255(dB, 255-sA) + md255(sB, 255-dA) + md255(sB, dB)
				// endregion BLEND-SPECIFIC EQUATION LOGIC
			} else {
				// Fallback path for other compositions, or for blend modes without a direct equation.
				// This path is accurate but slower as it must un-premultiply.
				sR = unpremultiply(sR, sA)
				sG = unpremultiply(sG, sA)
				sB = unpremultiply(sB, sA)

				dR = unpremultiply(dR, dA)
				dG = unpremultiply(dG, dA)
				dB = unpremultiply(dB, dA)

				// un-premultiplied kernel color results
				var kR, kG, kB uint32

				// region BLEND-SPECIFIC KERNEL LOGIC
				kR = md255(sR, dR)
				kG = md255(sG, dG)
				kB = md255(sB, dB)
				// endregion BLEND-SPECIFIC KERNEL LOGIC

				// premultiplied compositing color results
				var cRp, cGp, cBp, cA uint32

				// un-premultiplied output colors
				var oRu, oGu, oBu uint32

				switch compositing {
				case internal.CompositeBlendAndSrc:
					cRp = md255(md255(sA, 255-dA), sR) + md255(dA, kR)
					cGp = md255(md255(sA, 255-dA), sG) + md255(dA, kG)
					cBp = md255(md255(sA, 255-dA), sB) + md255(dA, kB)
					cA = dA + md255(sA, 255-dA)

					oRu = (cRp*255 + cA/2) / cA
					oGu = (cGp*255 + cA/2) / cA
					oBu = (cBp*255 + cA/2) / cA
					oA = sA
				case internal.CompositeBlendAndDst:
					cRp = md255(md255(dA, 255-sA), dR) + md255(sA, kR)
					cGp = md255(md255(dA, 255-sA), dG) + md255(sA, kG)
					cBp = md255(md255(dA, 255-sA), dB) + md255(sA, kB)
					cA = sA + md255(dA, 255-sA)

					oRu = (cRp*255 + cA/2) / cA
					oGu = (cGp*255 + cA/2) / cA
					oBu = (cBp*255 + cA/2) / cA
					oA = dA
				case internal.CompositeBlendOnly:
					oRu, oGu, oBu = kR, kG, kB
					oA = md255(sA, dA)
				}

				oRp = md255(oRu, oA)
				oGp = md255(oGu, oA)
				oBp = md255(oBu, oA)
			}

			out[i] = uint8(oRp)
			out[i+1] = uint8(oGp)
			out[i+2] = uint8(oBp)
			out[i+3] = uint8(oA)
		}
	})
}

// BlendOverlay performs a 'Overlay' blend on RGBA images.
// Logic: if Cd < 0.5 { Cr = 2 * Cs * Cd } else { Cr = 1 - 2 * (1 - Cs) * (1 - Cd) }
func BlendOverlay(pixIter core.PixelIterator, calc core.PixCalculator[*image.RGBA], compositing internal.BlendCompositing) *image.RGBA {
	return core.Iterate(pixIter, calc, func(dst, src, out []uint8) {
		for i := 0; i < len(src); i += 4 {
			sA := uint32(src[i+3])
			dA := uint32(dst[i+3])

			if sA == 0 {
				if compositing&internal.CompositeBlendAndDst != 0 {
					out[i], out[i+1], out[i+2], out[i+3] = dst[i], dst[i+1], dst[i+2], dst[i+3]
				} else {
					out[i], out[i+1], out[i+2], out[i+3] = 0, 0, 0, 0
				}
				continue
			}
			if dA == 0 {
				if compositing&internal.CompositeBlendAndSrc != 0 {
					out[i], out[i+1], out[i+2], out[i+3] = src[i], src[i+1], src[i+2], src[i+3]
				} else {
					out[i], out[i+1], out[i+2], out[i+3] = 0, 0, 0, 0
				}
				continue
			}

			// pre-multiplied source & destination colors
			sR, sG, sB := uint32(src[i]), uint32(src[i+1]), uint32(src[i+2])
			dR, dG, dB := uint32(dst[i]), uint32(dst[i+1]), uint32(dst[i+2])

			if (sA & dA) == 255 {
				// un-premultiplied kernel color results
				var kR, kG, kB uint32

				// region BLEND-SPECIFIC KERNEL LOGIC
				if dR < 128 {
					kR = 2 * md255(sR, dR)
				} else {
					kR = 255 - 2*md255(255-sR, 255-dR)
				}
				if dG < 128 {
					kG = 2 * md255(sG, dG)
				} else {
					kG = 255 - 2*md255(255-sG, 255-dG)
				}
				if dB < 128 {
					kB = 2 * md255(sB, dB)
				} else {
					kB = 255 - 2*md255(255-sB, 255-dB)
				}
				out[i] = uint8(kR)
				out[i+1] = uint8(kG)
				out[i+2] = uint8(kB)
				// endregion BLEND-SPECIFIC KERNEL LOGIC
				out[i+3] = uint8(255)
				continue
			}

			// final output colors & alpha
			var oRp, oGp, oBp, oA uint32
			{
				// Fallback path for other compositions, or for blend modes without a direct equation.
				// This path is accurate but slower as it must un-premultiply.
				sR = unpremultiply(sR, sA)
				sG = unpremultiply(sG, sA)
				sB = unpremultiply(sB, sA)

				dR = unpremultiply(dR, dA)
				dG = unpremultiply(dG, dA)
				dB = unpremultiply(dB, dA)

				// un-premultiplied kernel color results
				var kR, kG, kB uint32

				// region BLEND-SPECIFIC KERNEL LOGIC
				if dR < 128 {
					kR = 2 * md255(sR, dR)
				} else {
					kR = 255 - 2*md255(255-sR, 255-dR)
				}
				if dG < 128 {
					kG = 2 * md255(sG, dG)
				} else {
					kG = 255 - 2*md255(255-sG, 255-dG)
				}
				if dB < 128 {
					kB = 2 * md255(sB, dB)
				} else {
					kB = 255 - 2*md255(255-sB, 255-dB)
				}
				// endregion BLEND-SPECIFIC KERNEL LOGIC

				// premultiplied compositing color results
				var cRp, cGp, cBp, cA uint32

				// un-premultiplied output colors
				var oRu, oGu, oBu uint32

				switch compositing {
				case internal.CompositeAll:
					invSA, invDA := 255-sA, 255-dA
					term1, term2, term3 := md255(sA, invDA), md255(dA, invSA), md255(sA, dA)

					cRp = md255(term1, sR) + md255(term2, dR) + md255(term3, kR)
					cGp = md255(term1, sG) + md255(term2, dG) + md255(term3, kG)
					cBp = md255(term1, sB) + md255(term2, dB) + md255(term3, kB)
					cA = sA + term2

					oRu = (cRp*255 + cA/2) / cA
					oGu = (cGp*255 + cA/2) / cA
					oBu = (cBp*255 + cA/2) / cA
					oA = cA
				case internal.CompositeBlendAndSrc:
					cRp = md255(md255(sA, 255-dA), sR) + md255(dA, kR)
					cGp = md255(md255(sA, 255-dA), sG) + md255(dA, kG)
					cBp = md255(md255(sA, 255-dA), sB) + md255(dA, kB)
					cA = dA + md255(sA, 255-dA)

					oRu = (cRp*255 + cA/2) / cA
					oGu = (cGp*255 + cA/2) / cA
					oBu = (cBp*255 + cA/2) / cA
					oA = sA
				case internal.CompositeBlendAndDst:
					cRp = md255(md255(dA, 255-sA), dR) + md255(sA, kR)
					cGp = md255(md255(dA, 255-sA), dG) + md255(sA, kG)
					cBp = md255(md255(dA, 255-sA), dB) + md255(sA, kB)
					cA = sA + md255(dA, 255-sA)

					oRu = (cRp*255 + cA/2) / cA
					oGu = (cGp*255 + cA/2) / cA
					oBu = (cBp*255 + cA/2) / cA
					oA = dA
				case internal.CompositeBlendOnly:
					oRu, oGu, oBu = kR, kG, kB
					oA = md255(sA, dA)
				}

				oRp = md255(oRu, oA)
				oGp = md255(oGu, oA)
				oBp = md255(oBu, oA)
			}

			out[i] = uint8(oRp)
			out[i+1] = uint8(oGp)
			out[i+2] = uint8(oBp)
			out[i+3] = uint8(oA)
		}
	})
}

// BlendPinLight performs a 'PinLight' blend on RGBA images.
// Logic: if Cs < 0.5 { Cr = min(Cd, 2 * Cs) } else { Cr = max(Cd, 2 * Cs - 1) }
func BlendPinLight(pixIter core.PixelIterator, calc core.PixCalculator[*image.RGBA], compositing internal.BlendCompositing) *image.RGBA {
	return core.Iterate(pixIter, calc, func(dst, src, out []uint8) {
		for i := 0; i < len(src); i += 4 {
			sA := uint32(src[i+3])
			dA := uint32(dst[i+3])

			if sA == 0 {
				if compositing&internal.CompositeBlendAndDst != 0 {
					out[i], out[i+1], out[i+2], out[i+3] = dst[i], dst[i+1], dst[i+2], dst[i+3]
				} else {
					out[i], out[i+1], out[i+2], out[i+3] = 0, 0, 0, 0
				}
				continue
			}
			if dA == 0 {
				if compositing&internal.CompositeBlendAndSrc != 0 {
					out[i], out[i+1], out[i+2], out[i+3] = src[i], src[i+1], src[i+2], src[i+3]
				} else {
					out[i], out[i+1], out[i+2], out[i+3] = 0, 0, 0, 0
				}
				continue
			}

			// pre-multiplied source & destination colors
			sR, sG, sB := uint32(src[i]), uint32(src[i+1]), uint32(src[i+2])
			dR, dG, dB := uint32(dst[i]), uint32(dst[i+1]), uint32(dst[i+2])

			if (sA & dA) == 255 {
				// un-premultiplied kernel color results
				var kR, kG, kB uint32

				// region BLEND-SPECIFIC KERNEL LOGIC
				if sR < 128 {
					kR = min(dR, 2*sR)
				} else {
					kR = max(dR, 2*sR-255)
				}
				if sG < 128 {
					kG = min(dG, 2*sG)
				} else {
					kG = max(dG, 2*sG-255)
				}
				if sB < 128 {
					kB = min(dB, 2*sB)
				} else {
					kB = max(dB, 2*sB-255)
				}
				out[i] = uint8(kR)
				out[i+1] = uint8(kG)
				out[i+2] = uint8(kB)
				// endregion BLEND-SPECIFIC KERNEL LOGIC
				out[i+3] = uint8(255)
				continue
			}

			// final output colors & alpha
			var oRp, oGp, oBp, oA uint32
			{
				// Fallback path for other compositions, or for blend modes without a direct equation.
				// This path is accurate but slower as it must un-premultiply.
				sR = unpremultiply(sR, sA)
				sG = unpremultiply(sG, sA)
				sB = unpremultiply(sB, sA)

				dR = unpremultiply(dR, dA)
				dG = unpremultiply(dG, dA)
				dB = unpremultiply(dB, dA)

				// un-premultiplied kernel color results
				var kR, kG, kB uint32

				// region BLEND-SPECIFIC KERNEL LOGIC
				if sR < 128 {
					kR = min(dR, 2*sR)
				} else {
					kR = max(dR, 2*sR-255)
				}
				if sG < 128 {
					kG = min(dG, 2*sG)
				} else {
					kG = max(dG, 2*sG-255)
				}
				if sB < 128 {
					kB = min(dB, 2*sB)
				} else {
					kB = max(dB, 2*sB-255)
				}
				// endregion BLEND-SPECIFIC KERNEL LOGIC

				// premultiplied compositing color results
				var cRp, cGp, cBp, cA uint32

				// un-premultiplied output colors
				var oRu, oGu, oBu uint32

				switch compositing {
				case internal.CompositeAll:
					invSA, invDA := 255-sA, 255-dA
					term1, term2, term3 := md255(sA, invDA), md255(dA, invSA), md255(sA, dA)

					cRp = md255(term1, sR) + md255(term2, dR) + md255(term3, kR)
					cGp = md255(term1, sG) + md255(term2, dG) + md255(term3, kG)
					cBp = md255(term1, sB) + md255(term2, dB) + md255(term3, kB)
					cA = sA + term2

					oRu = (cRp*255 + cA/2) / cA
					oGu = (cGp*255 + cA/2) / cA
					oBu = (cBp*255 + cA/2) / cA
					oA = cA
				case internal.CompositeBlendAndSrc:
					cRp = md255(md255(sA, 255-dA), sR) + md255(dA, kR)
					cGp = md255(md255(sA, 255-dA), sG) + md255(dA, kG)
					cBp = md255(md255(sA, 255-dA), sB) + md255(dA, kB)
					cA = dA + md255(sA, 255-dA)

					oRu = (cRp*255 + cA/2) / cA
					oGu = (cGp*255 + cA/2) / cA
					oBu = (cBp*255 + cA/2) / cA
					oA = sA
				case internal.CompositeBlendAndDst:
					cRp = md255(md255(dA, 255-sA), dR) + md255(sA, kR)
					cGp = md255(md255(dA, 255-sA), dG) + md255(sA, kG)
					cBp = md255(md255(dA, 255-sA), dB) + md255(sA, kB)
					cA = sA + md255(dA, 255-sA)

					oRu = (cRp*255 + cA/2) / cA
					oGu = (cGp*255 + cA/2) / cA
					oBu = (cBp*255 + cA/2) / cA
					oA = dA
				case internal.CompositeBlendOnly:
					oRu, oGu, oBu = kR, kG, kB
					oA = md255(sA, dA)
				}

				oRp = md255(oRu, oA)
				oGp = md255(oGu, oA)
				oBp = md255(oBu, oA)
			}

			out[i] = uint8(oRp)
			out[i+1] = uint8(oGp)
			out[i+2] = uint8(oBp)
			out[i+3] = uint8(oA)
		}
	})
}

// BlendScreen performs a 'Screen' blend on RGBA images.
// Logic: Cr = 1 - (1 - Cs) * (1 - Cd)
func BlendScreen(pixIter core.PixelIterator, calc core.PixCalculator[*image.RGBA], compositing internal.BlendCompositing) *image.RGBA {
	return core.Iterate(pixIter, calc, func(dst, src, out []uint8) {
		for i := 0; i < len(src); i += 4 {
			sA := uint32(src[i+3])
			dA := uint32(dst[i+3])

			if sA == 0 {
				if compositing&internal.CompositeBlendAndDst != 0 {
					out[i], out[i+1], out[i+2], out[i+3] = dst[i], dst[i+1], dst[i+2], dst[i+3]
				} else {
					out[i], out[i+1], out[i+2], out[i+3] = 0, 0, 0, 0
				}
				continue
			}
			if dA == 0 {
				if compositing&internal.CompositeBlendAndSrc != 0 {
					out[i], out[i+1], out[i+2], out[i+3] = src[i], src[i+1], src[i+2], src[i+3]
				} else {
					out[i], out[i+1], out[i+2], out[i+3] = 0, 0, 0, 0
				}
				continue
			}

			// pre-multiplied source & destination colors
			sR, sG, sB := uint32(src[i]), uint32(src[i+1]), uint32(src[i+2])
			dR, dG, dB := uint32(dst[i]), uint32(dst[i+1]), uint32(dst[i+2])

			if (sA & dA) == 255 {
				// un-premultiplied kernel color results
				var kR, kG, kB uint32

				// region BLEND-SPECIFIC KERNEL LOGIC
				kR = 255 - md255(255-sR, 255-dR)
				kG = 255 - md255(255-sG, 255-dG)
				kB = 255 - md255(255-sB, 255-dB)
				out[i] = uint8(kR)
				out[i+1] = uint8(kG)
				out[i+2] = uint8(kB)
				// endregion BLEND-SPECIFIC KERNEL LOGIC
				out[i+3] = uint8(255)
				continue
			}

			// final output colors & alpha
			var oRp, oGp, oBp, oA uint32
			if compositing == internal.CompositeAll {
				// Fast path for Source Over using direct premultiplied equation
				oA = sA + md255(dA, 255-sA)
				// region BLEND-SPECIFIC EQUATION LOGIC
				oRp = sR + dR - md255(sR, dR)
				oGp = sG + dG - md255(sG, dG)
				oBp = sB + dB - md255(sB, dB)
				// endregion BLEND-SPECIFIC EQUATION LOGIC
			} else {
				// Fallback path for other compositions, or for blend modes without a direct equation.
				// This path is accurate but slower as it must un-premultiply.
				sR = unpremultiply(sR, sA)
				sG = unpremultiply(sG, sA)
				sB = unpremultiply(sB, sA)

				dR = unpremultiply(dR, dA)
				dG = unpremultiply(dG, dA)
				dB = unpremultiply(dB, dA)

				// un-premultiplied kernel color results
				var kR, kG, kB uint32

				// region BLEND-SPECIFIC KERNEL LOGIC
				kR = 255 - md255(255-sR, 255-dR)
				kG = 255 - md255(255-sG, 255-dG)
				kB = 255 - md255(255-sB, 255-dB)
				// endregion BLEND-SPECIFIC KERNEL LOGIC

				// premultiplied compositing color results
				var cRp, cGp, cBp, cA uint32

				// un-premultiplied output colors
				var oRu, oGu, oBu uint32

				switch compositing {
				case internal.CompositeBlendAndSrc:
					cRp = md255(md255(sA, 255-dA), sR) + md255(dA, kR)
					cGp = md255(md255(sA, 255-dA), sG) + md255(dA, kG)
					cBp = md255(md255(sA, 255-dA), sB) + md255(dA, kB)
					cA = dA + md255(sA, 255-dA)

					oRu = (cRp*255 + cA/2) / cA
					oGu = (cGp*255 + cA/2) / cA
					oBu = (cBp*255 + cA/2) / cA
					oA = sA
				case internal.CompositeBlendAndDst:
					cRp = md255(md255(dA, 255-sA), dR) + md255(sA, kR)
					cGp = md255(md255(dA, 255-sA), dG) + md255(sA, kG)
					cBp = md255(md255(dA, 255-sA), dB) + md255(sA, kB)
					cA = sA + md255(dA, 255-sA)

					oRu = (cRp*255 + cA/2) / cA
					oGu = (cGp*255 + cA/2) / cA
					oBu = (cBp*255 + cA/2) / cA
					oA = dA
				case internal.CompositeBlendOnly:
					oRu, oGu, oBu = kR, kG, kB
					oA = md255(sA, dA)
				}

				oRp = md255(oRu, oA)
				oGp = md255(oGu, oA)
				oBp = md255(oBu, oA)
			}

			out[i] = uint8(oRp)
			out[i+1] = uint8(oGp)
			out[i+2] = uint8(oBp)
			out[i+3] = uint8(oA)
		}
	})
}

// BlendSoftLight performs a 'SoftLight' blend on RGBA images.
// Logic: if Cs < 0.5 { Cr = Cd - (1 - 2*Cs) * Cd * (1 - Cd) } else { Cr = Cd + (2*Cs - 1) * (sqrt(Cd) - Cd) }
func BlendSoftLight(pixIter core.PixelIterator, calc core.PixCalculator[*image.RGBA], compositing internal.BlendCompositing) *image.RGBA {
	return core.Iterate(pixIter, calc, func(dst, src, out []uint8) {
		for i := 0; i < len(src); i += 4 {
			sA := uint32(src[i+3])
			dA := uint32(dst[i+3])

			if sA == 0 {
				if compositing&internal.CompositeBlendAndDst != 0 {
					out[i], out[i+1], out[i+2], out[i+3] = dst[i], dst[i+1], dst[i+2], dst[i+3]
				} else {
					out[i], out[i+1], out[i+2], out[i+3] = 0, 0, 0, 0
				}
				continue
			}
			if dA == 0 {
				if compositing&internal.CompositeBlendAndSrc != 0 {
					out[i], out[i+1], out[i+2], out[i+3] = src[i], src[i+1], src[i+2], src[i+3]
				} else {
					out[i], out[i+1], out[i+2], out[i+3] = 0, 0, 0, 0
				}
				continue
			}

			// pre-multiplied source & destination colors
			sR, sG, sB := uint32(src[i]), uint32(src[i+1]), uint32(src[i+2])
			dR, dG, dB := uint32(dst[i]), uint32(dst[i+1]), uint32(dst[i+2])

			if (sA & dA) == 255 {
				// un-premultiplied kernel color results
				var kR, kG, kB uint32

				// region BLEND-SPECIFIC KERNEL LOGIC
				if sR < 128 {
					kR = dR - div255(div255((255-2*sR)*dR*(255-dR)))
				} else {
					kR = dR + md255(2*sR-255, sqrt(dR)-dR)
				}
				if sG < 128 {
					kG = dG - div255(div255((255-2*sG)*dG*(255-dG)))
				} else {
					kG = dG + md255(2*sG-255, sqrt(dG)-dG)
				}
				if sB < 128 {
					kB = dB - div255(div255((255-2*sB)*dB*(255-dB)))
				} else {
					kB = dB + md255(2*sB-255, sqrt(dB)-dB)
				}
				out[i] = uint8(kR)
				out[i+1] = uint8(kG)
				out[i+2] = uint8(kB)
				// endregion BLEND-SPECIFIC KERNEL LOGIC
				out[i+3] = uint8(255)
				continue
			}

			// final output colors & alpha
			var oRp, oGp, oBp, oA uint32
			{
				// Fallback path for other compositions, or for blend modes without a direct equation.
				// This path is accurate but slower as it must un-premultiply.
				sR = unpremultiply(sR, sA)
				sG = unpremultiply(sG, sA)
				sB = unpremultiply(sB, sA)

				dR = unpremultiply(dR, dA)
				dG = unpremultiply(dG, dA)
				dB = unpremultiply(dB, dA)

				// un-premultiplied kernel color results
				var kR, kG, kB uint32

				// region BLEND-SPECIFIC KERNEL LOGIC
				if sR < 128 {
					kR = dR - div255(div255((255-2*sR)*dR*(255-dR)))
				} else {
					kR = dR + md255(2*sR-255, sqrt(dR)-dR)
				}
				if sG < 128 {
					kG = dG - div255(div255((255-2*sG)*dG*(255-dG)))
				} else {
					kG = dG + md255(2*sG-255, sqrt(dG)-dG)
				}
				if sB < 128 {
					kB = dB - div255(div255((255-2*sB)*dB*(255-dB)))
				} else {
					kB = dB + md255(2*sB-255, sqrt(dB)-dB)
				}
				// endregion BLEND-SPECIFIC KERNEL LOGIC

				// premultiplied compositing color results
				var cRp, cGp, cBp, cA uint32

				// un-premultiplied output colors
				var oRu, oGu, oBu uint32

				switch compositing {
				case internal.CompositeAll:
					invSA, invDA := 255-sA, 255-dA
					term1, term2, term3 := md255(sA, invDA), md255(dA, invSA), md255(sA, dA)

					cRp = md255(term1, sR) + md255(term2, dR) + md255(term3, kR)
					cGp = md255(term1, sG) + md255(term2, dG) + md255(term3, kG)
					cBp = md255(term1, sB) + md255(term2, dB) + md255(term3, kB)
					cA = sA + term2

					oRu = (cRp*255 + cA/2) / cA
					oGu = (cGp*255 + cA/2) / cA
					oBu = (cBp*255 + cA/2) / cA
					oA = cA
				case internal.CompositeBlendAndSrc:
					cRp = md255(md255(sA, 255-dA), sR) + md255(dA, kR)
					cGp = md255(md255(sA, 255-dA), sG) + md255(dA, kG)
					cBp = md255(md255(sA, 255-dA), sB) + md255(dA, kB)
					cA = dA + md255(sA, 255-dA)

					oRu = (cRp*255 + cA/2) / cA
					oGu = (cGp*255 + cA/2) / cA
					oBu = (cBp*255 + cA/2) / cA
					oA = sA
				case internal.CompositeBlendAndDst:
					cRp = md255(md255(dA, 255-sA), dR) + md255(sA, kR)
					cGp = md255(md255(dA, 255-sA), dG) + md255(sA, kG)
					cBp = md255(md255(dA, 255-sA), dB) + md255(sA, kB)
					cA = sA + md255(dA, 255-sA)

					oRu = (cRp*255 + cA/2) / cA
					oGu = (cGp*255 + cA/2) / cA
					oBu = (cBp*255 + cA/2) / cA
					oA = dA
				case internal.CompositeBlendOnly:
					oRu, oGu, oBu = kR, kG, kB
					oA = md255(sA, dA)
				}

				oRp = md255(oRu, oA)
				oGp = md255(oGu, oA)
				oBp = md255(oBu, oA)
			}

			out[i] = uint8(oRp)
			out[i+1] = uint8(oGp)
			out[i+2] = uint8(oBp)
			out[i+3] = uint8(oA)
		}
	})
}

// BlendSubtract performs a 'Subtract' blend on RGBA images.
// Logic: Cr = Cd - Cs
func BlendSubtract(pixIter core.PixelIterator, calc core.PixCalculator[*image.RGBA], compositing internal.BlendCompositing) *image.RGBA {
	return core.Iterate(pixIter, calc, func(dst, src, out []uint8) {
		for i := 0; i < len(src); i += 4 {
			sA := uint32(src[i+3])
			dA := uint32(dst[i+3])

			if sA == 0 {
				if compositing&internal.CompositeBlendAndDst != 0 {
					out[i], out[i+1], out[i+2], out[i+3] = dst[i], dst[i+1], dst[i+2], dst[i+3]
				} else {
					out[i], out[i+1], out[i+2], out[i+3] = 0, 0, 0, 0
				}
				continue
			}
			if dA == 0 {
				if compositing&internal.CompositeBlendAndSrc != 0 {
					out[i], out[i+1], out[i+2], out[i+3] = src[i], src[i+1], src[i+2], src[i+3]
				} else {
					out[i], out[i+1], out[i+2], out[i+3] = 0, 0, 0, 0
				}
				continue
			}

			// pre-multiplied source & destination colors
			sR, sG, sB := uint32(src[i]), uint32(src[i+1]), uint32(src[i+2])
			dR, dG, dB := uint32(dst[i]), uint32(dst[i+1]), uint32(dst[i+2])

			if (sA & dA) == 255 {
				// un-premultiplied kernel color results
				var kR, kG, kB uint32

				// region BLEND-SPECIFIC KERNEL LOGIC
				kR = uint32(max(int(dR)-int(sR), 0))
				kG = uint32(max(int(dG)-int(sG), 0))
				kB = uint32(max(int(dB)-int(sB), 0))
				out[i] = uint8(kR)
				out[i+1] = uint8(kG)
				out[i+2] = uint8(kB)
				// endregion BLEND-SPECIFIC KERNEL LOGIC
				out[i+3] = uint8(255)
				continue
			}

			// final output colors & alpha
			var oRp, oGp, oBp, oA uint32
			{
				// Fallback path for other compositions, or for blend modes without a direct equation.
				// This path is accurate but slower as it must un-premultiply.
				sR = unpremultiply(sR, sA)
				sG = unpremultiply(sG, sA)
				sB = unpremultiply(sB, sA)

				dR = unpremultiply(dR, dA)
				dG = unpremultiply(dG, dA)
				dB = unpremultiply(dB, dA)

				// un-premultiplied kernel color results
				var kR, kG, kB uint32

				// region BLEND-SPECIFIC KERNEL LOGIC
				kR = uint32(max(int(dR)-int(sR), 0))
				kG = uint32(max(int(dG)-int(sG), 0))
				kB = uint32(max(int(dB)-int(sB), 0))
				// endregion BLEND-SPECIFIC KERNEL LOGIC

				// premultiplied compositing color results
				var cRp, cGp, cBp, cA uint32

				// un-premultiplied output colors
				var oRu, oGu, oBu uint32

				switch compositing {
				case internal.CompositeAll:
					invSA, invDA := 255-sA, 255-dA
					term1, term2, term3 := md255(sA, invDA), md255(dA, invSA), md255(sA, dA)

					cRp = md255(term1, sR) + md255(term2, dR) + md255(term3, kR)
					cGp = md255(term1, sG) + md255(term2, dG) + md255(term3, kG)
					cBp = md255(term1, sB) + md255(term2, dB) + md255(term3, kB)
					cA = sA + term2

					oRu = (cRp*255 + cA/2) / cA
					oGu = (cGp*255 + cA/2) / cA
					oBu = (cBp*255 + cA/2) / cA
					oA = cA
				case internal.CompositeBlendAndSrc:
					cRp = md255(md255(sA, 255-dA), sR) + md255(dA, kR)
					cGp = md255(md255(sA, 255-dA), sG) + md255(dA, kG)
					cBp = md255(md255(sA, 255-dA), sB) + md255(dA, kB)
					cA = dA + md255(sA, 255-dA)

					oRu = (cRp*255 + cA/2) / cA
					oGu = (cGp*255 + cA/2) / cA
					oBu = (cBp*255 + cA/2) / cA
					oA = sA
				case internal.CompositeBlendAndDst:
					cRp = md255(md255(dA, 255-sA), dR) + md255(sA, kR)
					cGp = md255(md255(dA, 255-sA), dG) + md255(sA, kG)
					cBp = md255(md255(dA, 255-sA), dB) + md255(sA, kB)
					cA = sA + md255(dA, 255-sA)

					oRu = (cRp*255 + cA/2) / cA
					oGu = (cGp*255 + cA/2) / cA
					oBu = (cBp*255 + cA/2) / cA
					oA = dA
				case internal.CompositeBlendOnly:
					oRu, oGu, oBu = kR, kG, kB
					oA = md255(sA, dA)
				}

				oRp = md255(oRu, oA)
				oGp = md255(oGu, oA)
				oBp = md255(oBu, oA)
			}

			out[i] = uint8(oRp)
			out[i+1] = uint8(oGp)
			out[i+2] = uint8(oBp)
			out[i+3] = uint8(oA)
		}
	})
}

// BlendVividLight performs a 'VividLight' blend on RGBA images.
// Logic: if Cs < 0.5 { Cr = 1 - (1 - Cd) / (2 * Cs) } else { Cr = Cd / (2 * (1 - Cs)) }
func BlendVividLight(pixIter core.PixelIterator, calc core.PixCalculator[*image.RGBA], compositing internal.BlendCompositing) *image.RGBA {
	return core.Iterate(pixIter, calc, func(dst, src, out []uint8) {
		for i := 0; i < len(src); i += 4 {
			sA := uint32(src[i+3])
			dA := uint32(dst[i+3])

			if sA == 0 {
				if compositing&internal.CompositeBlendAndDst != 0 {
					out[i], out[i+1], out[i+2], out[i+3] = dst[i], dst[i+1], dst[i+2], dst[i+3]
				} else {
					out[i], out[i+1], out[i+2], out[i+3] = 0, 0, 0, 0
				}
				continue
			}
			if dA == 0 {
				if compositing&internal.CompositeBlendAndSrc != 0 {
					out[i], out[i+1], out[i+2], out[i+3] = src[i], src[i+1], src[i+2], src[i+3]
				} else {
					out[i], out[i+1], out[i+2], out[i+3] = 0, 0, 0, 0
				}
				continue
			}

			// pre-multiplied source & destination colors
			sR, sG, sB := uint32(src[i]), uint32(src[i+1]), uint32(src[i+2])
			dR, dG, dB := uint32(dst[i]), uint32(dst[i+1]), uint32(dst[i+2])

			if (sA & dA) == 255 {
				// un-premultiplied kernel color results
				var kR, kG, kB uint32

				// region BLEND-SPECIFIC KERNEL LOGIC
				switch {
				case sR == 0 || sR == 255:
					kR = sR
				case sR < 128:
					kR = 255 - min(((255-dR)*255+sR)/(2*sR), 255)
				default:
					kR = min(((dR*255)+(255-sR))/(510-2*sR), 255)
				}
				switch {
				case sG == 0 || sG == 255:
					kG = sG
				case sG < 128:
					kG = 255 - min(((255-dG)*255+sG)/(2*sG), 255)
				default:
					kG = min(((dG*255)+(255-sG))/(510-2*sG), 255)
				}
				switch {
				case sB == 0 || sB == 255:
					kB = sB
				case sB < 128:
					kB = 255 - min(((255-dB)*255+sB)/(2*sB), 255)
				default:
					kB = min(((dB*255)+(255-sB))/(510-2*sB), 255)
				}
				out[i] = uint8(kR)
				out[i+1] = uint8(kG)
				out[i+2] = uint8(kB)
				// endregion BLEND-SPECIFIC KERNEL LOGIC
				out[i+3] = uint8(255)
				continue
			}

			// final output colors & alpha
			var oRp, oGp, oBp, oA uint32
			{
				// Fallback path for other compositions, or for blend modes without a direct equation.
				// This path is accurate but slower as it must un-premultiply.
				sR = unpremultiply(sR, sA)
				sG = unpremultiply(sG, sA)
				sB = unpremultiply(sB, sA)

				dR = unpremultiply(dR, dA)
				dG = unpremultiply(dG, dA)
				dB = unpremultiply(dB, dA)

				// un-premultiplied kernel color results
				var kR, kG, kB uint32

				// region BLEND-SPECIFIC KERNEL LOGIC
				switch {
				case sR == 0 || sR == 255:
					kR = sR
				case sR < 128:
					kR = 255 - min(((255-dR)*255+sR)/(2*sR), 255)
				default:
					kR = min(((dR*255)+(255-sR))/(510-2*sR), 255)
				}
				switch {
				case sG == 0 || sG == 255:
					kG = sG
				case sG < 128:
					kG = 255 - min(((255-dG)*255+sG)/(2*sG), 255)
				default:
					kG = min(((dG*255)+(255-sG))/(510-2*sG), 255)
				}
				switch {
				case sB == 0 || sB == 255:
					kB = sB
				case sB < 128:
					kB = 255 - min(((255-dB)*255+sB)/(2*sB), 255)
				default:
					kB = min(((dB*255)+(255-sB))/(510-2*sB), 255)
				}
				// endregion BLEND-SPECIFIC KERNEL LOGIC

				// premultiplied compositing color results
				var cRp, cGp, cBp, cA uint32

				// un-premultiplied output colors
				var oRu, oGu, oBu uint32

				switch compositing {
				case internal.CompositeAll:
					invSA, invDA := 255-sA, 255-dA
					term1, term2, term3 := md255(sA, invDA), md255(dA, invSA), md255(sA, dA)

					cRp = md255(term1, sR) + md255(term2, dR) + md255(term3, kR)
					cGp = md255(term1, sG) + md255(term2, dG) + md255(term3, kG)
					cBp = md255(term1, sB) + md255(term2, dB) + md255(term3, kB)
					cA = sA + term2

					oRu = (cRp*255 + cA/2) / cA
					oGu = (cGp*255 + cA/2) / cA
					oBu = (cBp*255 + cA/2) / cA
					oA = cA
				case internal.CompositeBlendAndSrc:
					cRp = md255(md255(sA, 255-dA), sR) + md255(dA, kR)
					cGp = md255(md255(sA, 255-dA), sG) + md255(dA, kG)
					cBp = md255(md255(sA, 255-dA), sB) + md255(dA, kB)
					cA = dA + md255(sA, 255-dA)

					oRu = (cRp*255 + cA/2) / cA
					oGu = (cGp*255 + cA/2) / cA
					oBu = (cBp*255 + cA/2) / cA
					oA = sA
				case internal.CompositeBlendAndDst:
					cRp = md255(md255(dA, 255-sA), dR) + md255(sA, kR)
					cGp = md255(md255(dA, 255-sA), dG) + md255(sA, kG)
					cBp = md255(md255(dA, 255-sA), dB) + md255(sA, kB)
					cA = sA + md255(dA, 255-sA)

					oRu = (cRp*255 + cA/2) / cA
					oGu = (cGp*255 + cA/2) / cA
					oBu = (cBp*255 + cA/2) / cA
					oA = dA
				case internal.CompositeBlendOnly:
					oRu, oGu, oBu = kR, kG, kB
					oA = md255(sA, dA)
				}

				oRp = md255(oRu, oA)
				oGp = md255(oGu, oA)
				oBp = md255(oBu, oA)
			}

			out[i] = uint8(oRp)
			out[i+1] = uint8(oGp)
			out[i+2] = uint8(oBp)
			out[i+3] = uint8(oA)
		}
	})
}
